{
  "name": "01 - WhatsApp Patient Handler (AI Optimized)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp-webhook",
        "options": {}
      },
      "id": "c8b4c473-ddc6-428d-9436-c4ce22c718a4",
      "name": "WhatsApp Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [
        32,
        356
      ],
      "typeVersion": 2,
      "webhookId": "whatsapp-patient-handler-opt"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Tenant Config Loader' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "853da60b-8831-440f-b66b-0fe428e6bd84",
      "name": "Load Tenant Config",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        256,
        356
      ],
      "typeVersion": 1.2,
      "notes": "üîë Carrega configura√ß√£o espec√≠fica do tenant do banco de dados\n\n**Entrada**: Webhook payload com `body.instance` ou `instance_name`\n**Sa√≠da**: \n- `tenant_config` - Configura√ß√£o completa do tenant\n- `tenant_id` - UUID do tenant\n- `services_catalog` - Cat√°logo formatado de servi√ßos\n\n**Uso**: Chamado automaticamente antes de processar mensagens"
    },
    {
      "parameters": {
        "jsCode": "// Parse webhook data and detect message type intelligently\n// Handle different payload structures from Evolution API and Tenant Config Loader\nconst body = $json.body || $json;\nconst data = body?.data || body;\n\n// Try multiple paths to find message structure\nconst messageObj = body?.data?.message || body?.message || data?.message || {};\nconst keyObj = body?.data?.key || body?.key || data?.key || {};\n\n// Detect message type based on available fields\nlet messageType = body?.data?.messageType || data?.messageType || messageObj?.messageType || null;\n\n// If messageType not found, infer from message structure\nif (!messageType) {\n  if (messageObj.conversation || messageObj.extendedTextMessage?.text) {\n    messageType = 'conversation';\n  } else if (messageObj.imageMessage || body?.data?.message?.imageMessage) {\n    messageType = 'imageMessage';\n  } else if (messageObj.audioMessage || body?.data?.message?.audioMessage) {\n    messageType = 'audioMessage';\n  } else if (messageObj.videoMessage) {\n    messageType = 'videoMessage';\n  } else if (messageObj.documentMessage) {\n    messageType = 'documentMessage';\n  } else {\n    // Default to conversation if we have message_text or any text content\n    messageType = 'conversation';\n  }\n}\n\n// Extract message text (try multiple paths)\nconst messageText = messageObj.conversation\n  || messageObj.extendedTextMessage?.text\n  || body?.data?.message?.conversation\n  || body?.data?.message?.extendedTextMessage?.text\n  || messageObj.imageMessage?.caption\n  || '';\n\n// Extract remote JID (handle different formats)\nconst remoteJid = keyObj.remoteJid\n  || data?.remoteJid\n  || body?.remoteJid\n  || body?.from\n  || body?.data?.key?.remoteJid\n  || '';\n\n// Extract image URL\nconst imageMessage = messageObj.imageMessage || body?.data?.message?.imageMessage || {};\nconst imageUrl = imageMessage.url || imageMessage.directPath || '';\n\n// Extract audio URL\nconst audioMessage = messageObj.audioMessage || body?.data?.message?.audioMessage || {};\nconst audioUrl = audioMessage.url || audioMessage.directPath || '';\n\nreturn {\n  message_type: messageType,\n  remote_jid: remoteJid,\n  message_text: messageText,\n  message_id: keyObj.id || data?.id || body?.id || body?.data?.key?.id || '',\n  push_name: data?.pushName || body?.pushName || body?.senderName || data?.push_name || body?.data?.pushName || 'Paciente',\n  image_url: imageUrl,\n  audio_url: audioUrl,\n  tenant_config: $json.tenant_config,\n  tenant_id: $json.tenant_id,\n  services_catalog: $json.services_catalog,\n  // Preserve original for debugging\n  original_body: body,\n  original_data: data\n};"
      },
      "id": "2008bb09-460d-4b2c-a5d8-0ef4b4650166",
      "name": "Parse Webhook Data",
      "type": "n8n-nodes-base.code",
      "position": [
        480,
        356
      ],
      "typeVersion": 2,
      "notes": "üîß Detecta inteligentemente o tipo de mensagem e faz parse dos dados do webhook\n\n**Suporta**:\n- Mensagens de texto (conversation)\n- Mensagens de imagem (imageMessage)\n- Mensagens de √°udio (audioMessage)\n- Mensagens de v√≠deo (videoMessage)\n- Mensagens de documento (documentMessage)\n\n**Extrai**:\n- `message_type` - Tipo da mensagem\n- `remote_jid` - ID do remetente\n- `message_text` - Texto da mensagem\n- `image_url` / `audio_url` - URLs de m√≠dia"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "conversation",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "text"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "imageMessage",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "image"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "audioMessage",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "audio"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "477bf0f4-6163-428c-9fb1-e9b4525e3975",
      "name": "Message Type Switch",
      "type": "n8n-nodes-base.switch",
      "position": [
        704,
        324
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "a47a7940-5aed-4809-a2c0-273fda568e7a",
      "name": "Process Audio",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        928,
        548
      ],
      "typeVersion": 1.2,
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "fabfc9b4-a6e0-4c33-924d-f7f23820f206",
      "name": "Process Image",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        928,
        356
      ],
      "typeVersion": 1.2,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// ===================================\n// INTENT CLASSIFIER\n// Cost: ~$0 (no AI call)\n// Latency: ~10ms\n// ===================================\n\nconst text = ($json.message_text || $json.transcribed_text || '').trim();\nconst textLower = text.toLowerCase();\nconst tenantId = $json.tenant_id;\n\n// PRIORITY: Numbered menu options (1, 2, 3, 4) - handled first to avoid AI\n// These map directly to FAQ entries\nconst menuPatterns = {\n  '1': /^1$|^um$/i,\n  '2': /^2$|^dois$/i,\n  '3': /^3$|^tr[√™e]s$/i,\n  '4': /^4$|^quatro$/i\n};\n\n// Check for menu number first (highest priority)\nlet intent = 'complex'; // Default to AI processing\nlet confidence = 0;\nlet menuNumber = null;\nlet serviceNumber = null;\n\nfor (const [num, pattern] of Object.entries(menuPatterns)) {\n  if (pattern.test(text)) {\n    menuNumber = num;\n    // Map menu number to intent for FAQ lookup\n    const menuToIntent = {\n      '1': 'appointment',\n      '2': 'reschedule',\n      '3': 'info',\n      '4': 'hours_location'\n    };\n    intent = menuToIntent[num] || 'complex';\n    confidence = 0.95; // Very high confidence for menu selections\n    break;\n  }\n}\n\n// If not a menu number, check if it's a service catalog number (5 or higher)\nif (!menuNumber) {\n  // Check if text is a pure number (5 or higher) - likely a service selection\n  const numericMatch = text.match(/^(\\d+)$/);\n  if (numericMatch) {\n    const num = parseInt(numericMatch[1], 10);\n    if (num >= 5) {\n      // This is likely a service catalog number - process without AI\n      serviceNumber = num;\n      intent = 'service_selection';\n      confidence = 0.95;\n    }\n  }\n}\n\n// If not a menu number or service number, check other patterns\nif (!menuNumber && !serviceNumber) {\n  const patterns = {\n    greeting: /^(oi|ol√°|ola|bom dia|boa tarde|boa noite|hey|hello)/,\n    hours: /(hor√°rio|horario|hora|abre|fecha|aberto|funciona|atende)/,\n    location: /(endere√ßo|endereco|onde|localiza√ß√£o|localizacao|fica|chegar)/,\n    appointment: /(agendar|marcar|consulta|hor√°rio dispon√≠vel|horario disponivel|vaga)/,\n    cancel: /(cancelar|desmarcar|n√£o vou|nao vou)/,\n    reschedule: /(remarcar|mudar|alterar|trocar dia|trocar hora)/,\n    confirmation: /(sim|confirmo|confirmar|ok|tudo bem|pode ser)/,\n    help: /(ajuda|help|socorro|n√£o entendi|nao entendi)/\n  };\n\n  for (const [intentName, pattern] of Object.entries(patterns)) {\n    if (pattern.test(textLower)) {\n      intent = intentName;\n      confidence = 0.9;\n      break;\n    }\n  }\n}\n\n// Extract dates if present (simple regex for pt-BR)\nconst datePatterns = [\n  /\\d{1,2}[\\/\\-]\\d{1,2}(?:[\\/\\-]\\d{2,4})?/, // 10/01 or 10/01/2025\n  /(pr√≥xima|proxima|segunda|ter√ßa|terca|quarta|quinta|sexta|s√°bado|sabado|domingo)/,\n  /(amanh√£|amanha|hoje|depois de amanh√£|depois de amanha)/\n];\n\nlet extractedDate = null;\nfor (const pattern of datePatterns) {\n  const match = textLower.match(pattern);\n  if (match) {\n    extractedDate = match[0];\n    break;\n  }\n}\n\nreturn {\n  ...$json,\n  intent,\n  confidence,\n  menu_number: menuNumber, // Store menu number if selected\n  service_number: serviceNumber, // Store service catalog number if selected (5+)\n  extracted_date: extractedDate,\n  requires_ai: intent === 'complex' || (intent !== 'service_selection' && confidence < 0.8),\n  // For FAQ query: use menu number directly if present, otherwise use normalized text\n  message_text_normalized: menuNumber ? menuNumber : textLower.trim(),\n  intent_for_faq: intent || ''\n};"
      },
      "id": "312e65b3-ce75-40d4-a0a8-33366fc83c3a",
      "name": "Intent Classifier",
      "type": "n8n-nodes-base.code",
      "position": [
        1152,
        356
      ],
      "typeVersion": 2,
      "notes": "‚ö° Classifica√ß√£o r√°pida de inten√ß√£o sem chamada de IA (~10ms)\n\n**Detecta**:\n- Sauda√ß√µes (oi, ol√°, bom dia)\n- Hor√°rios (hor√°rio, abre, fecha)\n- Localiza√ß√£o (endere√ßo, onde fica)\n- Agendamento (agendar, marcar, consulta)\n- Cancelamento (cancelar, desmarcar)\n- Reagendamento (remarcar, mudar)\n- Confirma√ß√£o (sim, confirmo, ok)\n- Sele√ß√£o de menu (1, 2, 3, 4)\n- Sele√ß√£o de servi√ßo (5+)\n\n**Prioridade**: N√∫meros de menu e cat√°logo s√£o processados primeiro (sem IA)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Check FAQ cache first\n-- IMPORTANT: Always returns at least one row to keep workflow running\n-- Uses message_text_normalized and intent_for_faq from Intent Classifier\n-- Falls back to message_text and intent if normalized fields not available\nWITH faq_result AS (\n  SELECT \n    answer,\n    view_count,\n    question_original,\n    intent\n  FROM tenant_faq\n  WHERE tenant_id = '{{ $json.tenant_id }}'::UUID\n    AND is_active = true\n    AND (\n      question_normalized ILIKE '%{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}%'\n      OR ('{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}' != '' AND keywords @> ARRAY['{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}'])\n      OR ('{{ $json.intent_for_faq || $json.intent || \"\" }}' != '' AND intent = '{{ $json.intent_for_faq || $json.intent || \"\" }}')\n    )\n  ORDER BY view_count DESC, COALESCE(last_used_at, created_at) DESC\n  LIMIT 1\n)\nSELECT * FROM faq_result\nUNION ALL\nSELECT NULL::TEXT as answer, 0::INTEGER as view_count, NULL::TEXT as question_original, NULL::TEXT as intent\nWHERE NOT EXISTS (SELECT 1 FROM faq_result)\nLIMIT 1;",
        "options": {}
      },
      "id": "60e42164-4e14-47aa-83e9-ebdc7293b04c",
      "name": "Check FAQ Cache",
      "type": "n8n-nodes-base.postgres",
      "position": [
        1376,
        356
      ],
      "typeVersion": 2.4,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Verifica se podemos responder do cache de FAQs\n\n**Estrat√©gia**:\n- Busca por texto normalizado\n- Busca por palavras-chave\n- Busca por inten√ß√£o\n- Ordena por `view_count` e `last_used_at`\n\n**Retorna**:\n- `answer` - Resposta do FAQ (se encontrado)\n- `view_count` - Quantas vezes foi usado\n- `faq_found` - Boolean indicando se encontrou\n\n**Performance**: ~50ms vs ~800ms com IA"
    },
    {
      "parameters": {
        "jsCode": "// Merge FAQ result with Intent Classifier data\n// PostgreSQL node replaces input data, so we need to restore fields from Intent Classifier\nconst intentClassifierData = $('Intent Classifier').first()?.json || {};\nconst faqResult = $json || {};\n\n// Merge: Intent Classifier fields + FAQ result fields\n// FAQ fields (answer, view_count, question_original, intent) take precedence over Intent Classifier\nreturn {\n  // Preserve all Intent Classifier fields\n  ...intentClassifierData,\n  // Override with FAQ result fields (if found)\n  answer: faqResult.answer || null,\n  faq_view_count: faqResult.view_count || 0,\n  faq_question_original: faqResult.question_original || null,\n  faq_intent: faqResult.intent || null,\n  // Preserve FAQ answer separately for easy access\n  ...(faqResult.answer ? { faq_found: true } : { faq_found: false })\n};"
      },
      "id": "24707079-98e2-424a-ac9f-76fb1a59df51",
      "name": "Merge FAQ Result",
      "type": "n8n-nodes-base.code",
      "position": [
        1600,
        356
      ],
      "typeVersion": 2,
      "notes": "üîß Merges FAQ result with Intent Classifier data"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.intent !== 'service_selection' && ($json.answer || \"\").toString().trim() === \"\" }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "922161ae-eb18-4f4b-91f1-c5200e16be57",
      "name": "Needs AI?",
      "type": "n8n-nodes-base.if",
      "position": [
        1824,
        356
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.intent }}",
              "rightValue": "service_selection",
              "operator": {
                "type": "string",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "service-selection-router",
      "name": "Service Selection Router",
      "type": "n8n-nodes-base.if",
      "position": [
        1824,
        528
      ],
      "typeVersion": 2,
      "notes": "üîÄ Routes service selection to no-AI flow"
    },
    {
      "parameters": {
        "jsCode": "// Build dynamic system prompt with services catalog\nconst basePrompt = $json.tenant_config?.system_prompt_patient || '';\nconst servicesCatalog = $json.services_catalog || 'Nenhum servi√ßo cadastrado.';\n\n// Replace {{ $json.services_catalog }} placeholder with actual catalog\nconst systemPrompt = basePrompt.replace(\n  /\\{\\{ \\$json\\.services_catalog \\}\\}/g,\n  servicesCatalog\n);\n\n// CRITICAL: Preserve tenant_id and all essential fields for tools\nreturn {\n  ...$json,\n  system_prompt_with_catalog: systemPrompt,\n  // Explicitly preserve tenant_id (critical for tool workflows)\n  tenant_id: $json.tenant_id || $('Merge FAQ Result').item.json.tenant_id || $('Parse Webhook Data').item.json.tenant_id || null,\n  // Preserve tenant_config for reference\n  tenant_config: $json.tenant_config || $('Merge FAQ Result').item.json.tenant_config || $('Parse Webhook Data').item.json.tenant_config || null\n};"
      },
      "id": "8c2fa97c-a3cf-4aed-8699-37928e6e9572",
      "name": "Build Prompt with Catalog",
      "type": "n8n-nodes-base.code",
      "position": [
        2048,
        232
      ],
      "typeVersion": 2,
      "notes": "üîß Injects services catalog into prompt dynamically"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message_text || $json.transcribed_text || $json.extracted_text }}",
        "options": {
          "systemMessage": "={{ $json.system_prompt_with_catalog || $json.tenant_config.system_prompt_patient }}"
        }
      },
      "id": "95f4ec65-9d8f-4eb5-9f06-6714a32f1989",
      "name": "Patient Assistant Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        2520,
        128
      ],
      "typeVersion": 1.8,
      "notes": "ü§ñ Agente de IA para pacientes - chamado apenas quando FAQ n√£o tem resposta\n\n**Modelo**: Mistral 7B (via OpenRouter)\n**Mem√≥ria**: 5 mensagens (reduzido para economia)\n**Ferramentas**:\n- FindProfessionals - Busca profissionais por servi√ßo\n- ListCalendarEvents - Lista eventos para reagendar/cancelar\n- CheckCalendarAvailability - Consulta hor√°rios dispon√≠veis\n- CreateCalendarEvent - Cria agendamento\n- UpdateCalendarEvent - Reagenda (atualiza) agendamento existente\n- DeleteCalendarEvent - Cancela (exclui) agendamento\n- CallToHuman - Escala√ß√£o para humano\n\n**Prompt**: Injetado dinamicamente com cat√°logo de servi√ßos do tenant"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.tenant_id }}_{{ $json.remote_jid }}"
      },
      "id": "4e968893-e43f-457e-b932-4bd4e66bed54",
      "name": "Postgres Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "position": [
        2400,
        352
      ],
      "typeVersion": 1.3,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Reduced window: 5 instead of 10"
    },
    {
      "parameters": {
        "name": "FindProfessionals",
        "description": "Busca profissionais que oferecem um servi√ßo espec√≠fico. Use quando o cliente escolher um servi√ßo para verificar quantos profissionais oferecem e seus pre√ßos/dura√ß√µes. Retorna lista de profissionais com calendar_id de cada um. IMPORTANTE: Esta ferramenta recebe tenant_id automaticamente do contexto - voc√™ s√≥ precisa fornecer o service_name.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Find Professionals Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $('Parse Webhook Data').first()?.json?.tenant_id || $('Build Prompt with Catalog').first()?.json?.tenant_id || $('Merge FAQ Result').first()?.json?.tenant_id || '' }}",
            "service_name": "={{ $fromAI('service_name', '', 'string') }}"
          }
        }
      },
      "id": "5afa68f8-3516-4265-b11a-6b1110286e69",
      "name": "Find Professionals Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        2528,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üîç Busca profissionais que oferecem um servi√ßo"
    },
    {
      "parameters": {
        "name": "ListCalendarEvents",
        "description": "Lista eventos existentes de um calend√°rio do Google Calendar. Use ANTES de reagendar ou cancelar para encontrar o event_id do agendamento. Retorna todos os eventos no per√≠odo especificado, incluindo event_id, summary, start e end. IMPORTANTE: Use o calendar_id do profissional. Para encontrar agendamentos do paciente, busque por nome ou telefone no summary/description dos eventos retornados.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar List Events Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "time_min": "={{ $fromAI('time_min', new Date().toISOString(), 'string') }}",
            "time_max": "={{ $fromAI('time_max', new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), 'string') }}"
          }
        }
      },
      "id": "list-calendar-events-tool",
      "name": "List Calendar Events",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        2592,
        480
      ],
      "typeVersion": 2.1,
      "notes": "üìã Lista eventos para reagendar/cancelar"
    },
    {
      "parameters": {
        "name": "CheckCalendarAvailability",
        "description": "Consulta hor√°rios dispon√≠veis em um calend√°rio do Google Calendar. Use quando o cliente escolher um profissional e servi√ßo. Retorna as 10 op√ß√µes de hor√°rio mais pr√≥ximas, considerando a dura√ß√£o do procedimento. IMPORTANTE: Use o calendar_id e duration_minutes retornados por FindProfessionals. O start_time deve ser a partir de agora (data/hora atual). O end_time deve ser 7 dias no futuro. Retorna apenas as 10 op√ß√µes mais pr√≥ximas que t√™m tempo suficiente para o procedimento.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar Availability Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "start_time": "={{ $fromAI('start_time', new Date().toISOString(), 'string') }}",
            "end_time": "={{ $fromAI('end_time', new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), 'string') }}",
            "duration_minutes": "={{ $fromAI('duration_minutes', 30, 'number') }}"
          }
        }
      },
      "id": "a3ab3bc2-91d3-4868-b7b4-ef4ab032edf6",
      "name": "Check Calendar Availability",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        2656,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Consulta disponibilidade usando Google Calendar API"
    },
    {
      "parameters": {
        "name": "CreateCalendarEvent",
        "description": "Cria um evento no Google Calendar. Use quando o cliente escolher um hor√°rio. IMPORTANTE: Use o calendar_id do profissional escolhido. Inclua na descri√ß√£o: nome completo, data de nascimento, telefone (extrair de remote_jid do WhatsApp) e servi√ßo. N√ÉO solicite telefone do cliente - j√° est√° dispon√≠vel via WhatsApp.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar Create Event Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "summary": "={{ $fromAI('summary', '', 'string') }}",
            "start": "={{ $fromAI('start', '', 'string') }}",
            "end": "={{ $fromAI('end', '', 'string') }}",
            "description": "={{ $fromAI('description', '', 'string') }}"
          }
        }
      },
      "id": "556b54c4-c687-49ee-a971-b56bc866b2b3",
      "name": "Create Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        2784,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Cria evento usando Google Calendar API"
    },
    {
      "parameters": {
        "name": "CallToHuman",
        "description": "Use essa ferramenta para escalar atendimento para humano em casos urgentes ou complexos",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Call to Human Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "patient_name": "={{ $fromAI('patient_name', '', 'string') }}",
            "phone_number": "={{ $json.remote_jid }}",
            "last_message": "={{ $fromAI('last_message', '', 'string') }}",
            "telegram_chat_id": "={{ $json.tenant_config.telegram_internal_chat_id }}",
            "instance_name": "={{ $json.tenant_config.evolution_instance_name }}",
            "reason": "={{ $fromAI('reason', 'Escala√ß√£o solicitada pelo paciente', 'string') }}"
          }
        }
      },
      "id": "1d9bf639-4191-41cd-bed1-d17a83b80e16",
      "name": "Human Escalation Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        2912,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üìû Escala√ß√£o para atendimento humano\n\n**Multi-tenant**: Usa telegram_chat_id e instance_name do tenant"
    },
    {
      "parameters": {
        "name": "UpdateCalendarEvent",
        "description": "Atualiza (reagenda) um evento existente no Google Calendar. Use quando o cliente quiser mudar o hor√°rio de um agendamento existente. Requer: calendar_id do profissional, event_id do agendamento, novo start e end. Use ListCalendarEvents primeiro para encontrar o event_id do agendamento a ser reagendado.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar Update Event Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "event_id": "={{ $fromAI('event_id', '', 'string') }}",
            "start": "={{ $fromAI('start', '', 'string') }}",
            "end": "={{ $fromAI('end', '', 'string') }}",
            "summary": "={{ $fromAI('summary', '', 'string') }}",
            "description": "={{ $fromAI('description', '', 'string') }}"
          }
        }
      },
      "id": "update-calendar-event-tool",
      "name": "Update Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3040,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Reagenda evento existente no Google Calendar"
    },
    {
      "parameters": {
        "name": "DeleteCalendarEvent",
        "description": "Cancela (exclui) um agendamento do Google Calendar. Use quando o cliente confirmar que deseja cancelar um agendamento. Requer: calendar_id do profissional e event_id do agendamento. Use ListCalendarEvents primeiro para encontrar o event_id. O sistema enviar√° um alerta para a equipe automaticamente.",
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar Delete Event Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "event_id": "={{ $fromAI('event_id', '', 'string') }}",
            "patient_name": "={{ $fromAI('patient_name', '', 'string') }}",
            "patient_phone": "={{ $json.remote_jid }}",
            "reason": "={{ $fromAI('reason', 'Cancelamento solicitado pelo paciente', 'string') }}",
            "telegram_chat_id": "={{ $json.tenant_config.telegram_internal_chat_id }}",
            "send_alert": true
          }
        }
      },
      "id": "delete-calendar-event-tool",
      "name": "Delete Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3168,
        352
      ],
      "typeVersion": 2.1,
      "notes": "üö´ Cancela agendamento e notifica equipe"
    },
    {
      "parameters": {
        "jsCode": "// ===================================\n// SIMPLE MESSAGE FORMATTER\n// Replaces AI-based formatter\n// Cost: ~$0 (no AI call)\n// Latency: ~5ms vs ~800ms\n// ===================================\n\n// Try multiple sources in order of priority:\n// 1. formatted_text (from Use FAQ Answer node - may contain \\n literals)\n// 2. output (from Patient Assistant Agent - LangChain agent)\n// 3. answer (from Check FAQ Cache - raw database result)\n// 4. text (alternative agent output field)\n// 5. message_text (fallback)\nconst rawText = $json.formatted_text || $json.output || $json.answer || $json.text || $json.message_text || '';\n\n// Validate we have text to format\nif (!rawText || (typeof rawText === 'string' && rawText.trim() === '')) {\n  console.log('Format Message: No text found in:', Object.keys($json));\n  return {\n    ...$json,\n    formatted_text: 'Desculpe, ocorreu um erro. Por favor, tente novamente.'\n  };\n}\n\n// Convert to string if needed\nconst textToFormat = String(rawText);\n\n// Simple formatting rules for WhatsApp\n// IMPORTANT: Always process text to convert \\n literals to actual newlines\nlet formatted = textToFormat\n  // Replace literal \\\\n (escaped backslash + n) with actual newlines\n  // This handles strings coming from database or JSON that have \\n as literal characters\n  .replace(/\\\\n/g, '\\n')\n  // Also handle \\r\\n (Windows line breaks)\n  .replace(/\\\\r\\\\n/g, '\\n')\n  // Handle \\r (old Mac line breaks)\n  .replace(/\\\\r/g, '\\n')\n  // Convert markdown bold ** to WhatsApp bold *\n  .replace(/\\*\\*(.+?)\\*\\*/g, '*$1*')\n  // Remove markdown headers #\n  .replace(/^#{1,6}\\s+/gm, '')\n  // Convert markdown lists to WhatsApp bullets\n  .replace(/^[-*]\\s+/gm, '‚Ä¢ ')\n  // Clean up excessive newlines (3+ become 2)\n  .replace(/\\n{3,}/g, '\\n\\n')\n  // Trim whitespace\n  .trim();\n\n// Preserve all original fields and add formatted_text\nreturn {\n  ...$json,\n  formatted_text: formatted,\n  // Explicitly preserve essential fields for Update FAQ Cache (in case they were lost)\n  tenant_id: $json.tenant_id || $('Parse Webhook Data')?.first()?.json?.tenant_id,\n  message_text: $json.message_text || $json.message_text_normalized || $('Parse Webhook Data')?.first()?.json?.message_text || '',\n  intent: $json.intent || $json.intent_for_faq || $('Parse Webhook Data')?.first()?.json?.intent || ''\n};"
      },
      "id": "167ba93e-d469-4092-8a48-1caf4c62c0da",
      "name": "Format Message (Code)",
      "type": "n8n-nodes-base.code",
      "position": [
        3120,
        356
      ],
      "typeVersion": 2,
      "notes": "‚ö° Formatador de mensagens sem IA (~5ms vs ~800ms)\n\n**Convers√µes**:\n- Markdown `**bold**` ‚Üí WhatsApp `*bold*`\n- Literal `\\n` ‚Üí Quebras de linha reais\n- Headers `#` ‚Üí Removidos\n- Listas markdown ‚Üí Bullets WhatsApp\n- Limpeza de espa√ßos excessivos\n\n**Performance**: ~5ms (vs ~800ms com IA)\n**Custo**: $0 (vs ~$0.001 por mensagem com IA)"
    },
    {
      "parameters": {
        "resource": "messages-api",
        "instanceName": "={{ $('Parse Webhook Data').item.json.tenant_config.evolution_instance_name }}",
        "remoteJid": "={{ $('Parse Webhook Data').item.json.remote_jid }}",
        "messageText": "={{ $json.formatted_text }}",
        "options_message": {}
      },
      "id": "27995d30-c506-489f-9f60-5c87f6e483d1",
      "name": "Send WhatsApp Response",
      "type": "n8n-nodes-evolution-api.evolutionApi",
      "position": [
        3344,
        284
      ],
      "typeVersion": 1,
      "credentials": {
        "evolutionApi": {
          "id": "xQSYKSSdn2xKsrdJ",
          "name": "Evolution account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Update FAQ view count or insert new FAQ\n-- Get tenant_id from current node, fallback to Parse Webhook Data if needed\n-- This will fail gracefully if tenant_id is empty (workflow will continue)\nINSERT INTO tenant_faq (\n  tenant_id,\n  question_original,\n  question_normalized,\n  answer,\n  answer_type,\n  keywords,\n  intent,\n  view_count\n) VALUES (\n  '{{ $json.tenant_id || $('Parse Webhook Data').first()?.json?.tenant_id }}'::UUID,\n  '{{ ($json.message_text || $('Parse Webhook Data').first()?.json?.message_text || \"unknown\").replace(/'/g, \"''\") }}',\n  LOWER('{{ ($json.message_text || $('Parse Webhook Data').first()?.json?.message_text || \"unknown\").replace(/'/g, \"''\") }}'),\n  '{{ ($json.formatted_text || \"no answer\").replace(/'/g, \"''\") }}',\n  'text',\n  ARRAY['{{ ($json.intent || $('Parse Webhook Data').first()?.json?.intent || \"unknown\").replace(/'/g, \"''\") }}'],\n  '{{ ($json.intent || $('Parse Webhook Data').first()?.json?.intent || \"\").replace(/'/g, \"''\") }}',\n  1\n)\nON CONFLICT (tenant_id, question_normalized)\nDO UPDATE SET\n  view_count = tenant_faq.view_count + 1,\n  last_used_at = NOW(),\n  answer = EXCLUDED.answer,\n  intent = EXCLUDED.intent;",
        "options": {}
      },
      "id": "89c456ae-4ec5-47cc-b428-4c138a7e357d",
      "name": "Update FAQ Cache",
      "type": "n8n-nodes-base.postgres",
      "position": [
        3344,
        476
      ],
      "typeVersion": 2.4,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Aprende com intera√ß√µes para melhorar o FAQ\n\n**Funcionalidade**:\n- Insere nova FAQ se n√£o existir\n- Atualiza `view_count` se j√° existir\n- Atualiza `last_used_at` para ordena√ß√£o\n- Normaliza pergunta para busca futura\n\n**Efeito**: Sistema melhora automaticamente com o tempo"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "formatted_text",
              "name": "formatted_text",
              "type": "string",
              "value": "={{ $json.answer }}"
            }
          ]
        },
        "options": {}
      },
      "id": "0d634252-6846-4859-ac0b-c952147a873f",
      "name": "Use FAQ Answer",
      "type": "n8n-nodes-base.set",
      "position": [
        2584,
        528
      ],
      "typeVersion": 3.4,
      "notes": "‚úÖ Skip AI entirely - use cached answer"
    },
    {
      "parameters": {
        "content": "## üìã 01 - WhatsApp Patient Handler (AI Optimized)\n\n**Vers√£o**: 3.0 - Refatorado com base no Material Secret√°ria v3\n\n### üéØ Funcionalidades Principais\n- ‚úÖ Atendimento multi-tenant via WhatsApp\n- ‚úÖ Suporte completo a m√∫ltiplos profissionais e servi√ßos\n- ‚úÖ Cache de FAQs (~75% redu√ß√£o em chamadas de IA)\n- ‚úÖ Processamento inteligente (texto, √°udio, imagem)\n- ‚úÖ Agendamento com sele√ß√£o de profissional e servi√ßo\n\n### ‚ö° Otimiza√ß√µes de Performance\n1. ‚ö° Intent Classifier (sem IA - ~10ms)\n2. üíæ FAQ Cache (Postgres - respostas instant√¢neas)\n3. üéØ Conditional AI (apenas quando necess√°rio)\n4. üìù Code-based formatter (sem IA - ~5ms)\n5. üß† Reduced memory window (5 vs 10 mensagens)\n6. üìä Automatic FAQ learning (aprende com intera√ß√µes)\n\n### üîÑ Fluxo de Processamento\n- **Consultas simples** ‚Üí FAQ cache (0 chamadas de IA)\n- **Consultas complexas** ‚Üí Processamento completo com IA\n- **Todas as respostas** ‚Üí Cacheadas para uso futuro\n\n### üèóÔ∏è Arquitetura Multi-Profissional\n- Cada profissional tem seu pr√≥prio `calendar_id`\n- Dura√ß√£o espec√≠fica por profissional para cada servi√ßo\n- Pre√ßos podem variar entre profissionais\n- Sistema identifica automaticamente o profissional correto\n\n### üìä M√©tricas de Performance\n- **Redu√ß√£o de custos**: ~75% menos chamadas de IA\n- **Velocidade**: 3-5x mais r√°pido para consultas comuns\n- **Lat√™ncia FAQ**: ~50ms (vs ~800ms com IA)\n- **Lat√™ncia formatter**: ~5ms (vs ~800ms com IA)",
        "height": 600,
        "width": 500,
        "color": 5
      },
      "id": "62c3c1f0-4a8d-412f-aed3-1982bae6c57f",
      "name": "Sticky Note - Documenta√ß√£o Principal",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": "mistralai/mistral-7b-instruct:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2272,
        352
      ],
      "id": "eb9d8a37-3c96-426e-ad4c-5f8fa75fc7fd",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "QfRFeOCfFzxb41Xh",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT * FROM get_service_by_number('{{ $json.tenant_id }}'::UUID, {{ $json.service_number }}::INTEGER);",
        "options": {}
      },
      "id": "get-service-by-number",
      "name": "Get Service by Number",
      "type": "n8n-nodes-base.postgres",
      "position": [
        1824,
        528
      ],
      "typeVersion": 2.4,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üîç Get service details by catalog number (no AI)"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Find Professionals Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "service_name": "={{ $json.service_name }}"
          }
        },
        "options": {}
      },
      "id": "find-professionals-direct",
      "name": "Find Professionals (Direct)",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        2048,
        528
      ],
      "typeVersion": 1.2,
      "notes": "üîç Find professionals for selected service (no AI)"
    },
    {
      "parameters": {
        "jsCode": "// Process professionals and prepare for calendar check\nconst serviceData = $('Get Service by Number').first()?.json || {};\nconst professionalsData = $json || {};\n\n// Get professionals array\nconst professionals = professionalsData.professionals || [];\n\nif (professionals.length === 0) {\n  return {\n    ...$json,\n    formatted_text: 'Desculpe, n√£o encontrei profissionais dispon√≠veis para este servi√ßo no momento.'\n  };\n}\n\n// If single professional, prepare for direct calendar check\nif (professionals.length === 1) {\n  const prof = professionals[0];\n  const service = prof.services?.[0] || {};\n  return {\n    ...$json,\n    ...serviceData,\n    professional: prof,\n    professional_id: prof.professional_id,\n    professional_name: prof.professional_name,\n    google_calendar_id: prof.google_calendar_id,\n    duration_minutes: service.duration_minutes || 30,\n    price_display: service.price_display || 'R$ 0,00',\n    single_professional: true,\n    // Prepare for calendar check\n    calendar_check_needed: true\n  };\n}\n\n// Multiple professionals - expand each professional into a separate item for calendar check\n// This will create one item per professional for parallel processing\nconst expandedItems = professionals.map((prof) => {\n  const service = prof.services?.[0] || {};\n  return {\n    ...serviceData,\n    professional: prof,\n    professional_id: prof.professional_id,\n    professional_name: prof.professional_name,\n    google_calendar_id: prof.google_calendar_id,\n    duration_minutes: service.duration_minutes || 30,\n    price_display: service.price_display || 'R$ 0,00',\n    single_professional: false,\n    calendar_check_needed: true,\n    multiple_professionals: true,\n    total_professionals: professionals.length\n  };\n});\n\n// Return array to expand into multiple items\nreturn expandedItems;"
      },
      "id": "process-professionals",
      "name": "Process Professionals",
      "type": "n8n-nodes-base.code",
      "position": [
        2272,
        528
      ],
      "typeVersion": 2,
      "notes": "‚öôÔ∏è Process professionals list (no AI)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.single_professional }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-single-professional",
      "name": "Single Professional?",
      "type": "n8n-nodes-base.if",
      "position": [
        2496,
        528
      ],
      "typeVersion": 2,
      "notes": "üîÄ Check if single professional (direct calendar) or multiple (user choice)"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "{{ 'Google Calendar Availability Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $json.google_calendar_id }}",
            "start_time": "={{ new Date().toISOString() }}",
            "end_time": "={{ new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() }}",
            "duration_minutes": "={{ $json.duration_minutes || 30 }}"
          }
        },
        "options": {}
      },
      "id": "check-calendar-direct",
      "name": "Check Calendar (Direct)",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        2720,
        432
      ],
      "typeVersion": 1.2,
      "notes": "üìÖ Check calendar availability (no AI)"
    },
    {
      "parameters": {
        "jsCode": "// Format calendar availability slots for presentation\n// Check if we have multiple items (multiple professionals)\nconst allItems = $input.all();\nconst isMultiple = allItems.length > 1;\n\n// Get service data\nconst service = $('Get Service by Number').first()?.json || {};\n\nif (isMultiple) {\n  // Multiple professionals - collect all results and format together\n  const professionalResults = allItems.map((item, index) => {\n    const calendarData = item.json || {};\n    const slots = calendarData.available_slots || [];\n    const professional = item.json.professional || item.json.professional_name ? { professional_name: item.json.professional_name } : {};\n    \n    // Show 5 slots per professional\n    const slotsToShow = slots.slice(0, 5);\n    \n    if (slotsToShow.length === 0) {\n      return `\\n*${professional.professional_name || 'Profissional ' + (index + 1)}:*\\nSem hor√°rios dispon√≠veis nos pr√≥ximos 7 dias.`;\n    }\n    \n    const slotsFormatted = slotsToShow.map((slot, idx) => {\n      return `  ${idx + 1}. ${slot.date_formatted} √†s ${slot.start_formatted}`;\n    }).join('\\n');\n    \n    return `\\n*${professional.professional_name || 'Profissional ' + (index + 1)}:*\\n${slotsFormatted}`;\n  }).join('\\n\\n');\n  \n  return {\n    ...allItems[0].json,\n    ...service,\n    formatted_text: `üìÖ *Hor√°rios dispon√≠veis para ${service.service_name || 'este servi√ßo'}:*\\n${professionalResults}\\n\\n*Qual profissional e hor√°rio voc√™ prefere? (Responda com o n√∫mero do profissional e do hor√°rio)*`,\n    multiple_professionals: true\n  };\n} else {\n  // Single professional - format as before (10 slots)\n  const calendarData = $json || {};\n  const slots = calendarData.available_slots || [];\n  const professional = $('Process Professionals').first()?.json?.professional || {};\n  \n  if (slots.length === 0) {\n    return {\n      ...$json,\n      formatted_text: `Desculpe, n√£o encontrei hor√°rios dispon√≠veis para *${service.service_name || 'este servi√ßo'}* com ${professional.professional_name || 'o profissional'} nos pr√≥ximos 7 dias.\\n\\nPor favor, tente novamente mais tarde ou entre em contato conosco.`\n    };\n  }\n  \n  // Show 10 slots for single professional\n  const slotsToShow = slots.slice(0, 10);\n  const slotsListFormatted = slotsToShow.map((slot, idx) => {\n    return `${idx + 1}. ${slot.date_formatted} √†s ${slot.start_formatted} (dura√ß√£o: ${slot.duration_minutes}min)`;\n  }).join('\\n');\n  \n  return {\n    ...$json,\n    ...professional,\n    ...service,\n    formatted_text: `üìÖ *Hor√°rios dispon√≠veis para ${service.service_name || 'este servi√ßo'} com ${professional.professional_name || 'o profissional'}:*\\n\\n${slotsListFormatted}\\n\\n*Qual hor√°rio voc√™ prefere? (Responda com o n√∫mero)*`,\n    available_slots: slots,\n    slots_count: slots.length\n  };\n}"
      },
      "id": "format-calendar-slots",
      "name": "Format Calendar Slots",
      "type": "n8n-nodes-base.code",
      "position": [
        2944,
        432
      ],
      "typeVersion": 2,
      "notes": "üìù Format calendar slots for presentation (no AI)"
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Webhook": {
      "main": [
        [
          {
            "node": "Load Tenant Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Tenant Config": {
      "main": [
        [
          {
            "node": "Parse Webhook Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Webhook Data": {
      "main": [
        [
          {
            "node": "Message Type Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message Type Switch": {
      "main": [
        [
          {
            "node": "Intent Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Audio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Audio": {
      "main": [
        [
          {
            "node": "Intent Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image": {
      "main": [
        [
          {
            "node": "Intent Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intent Classifier": {
      "main": [
        [
          {
            "node": "Check FAQ Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check FAQ Cache": {
      "main": [
        [
          {
            "node": "Merge FAQ Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge FAQ Result": {
      "main": [
        [
          {
            "node": "Needs AI?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs AI?": {
      "main": [
        [
          {
            "node": "Build Prompt with Catalog",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Service Selection Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Service Selection Router": {
      "main": [
        [
          {
            "node": "Get Service by Number",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Use FAQ Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Service by Number": {
      "main": [
        [
          {
            "node": "Find Professionals (Direct)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Professionals (Direct)": {
      "main": [
        [
          {
            "node": "Process Professionals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Professionals": {
      "main": [
        [
          {
            "node": "Single Professional?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Single Professional?": {
      "main": [
        [
          {
            "node": "Check Calendar (Direct)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Calendar (Direct)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Calendar (Direct)": {
      "main": [
        [
          {
            "node": "Format Calendar Slots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Calendar Slots": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt with Catalog": {
      "main": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Patient Assistant Agent": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use FAQ Answer": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Message (Code)": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update FAQ Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Find Professionals Tool": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "List Calendar Events": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Check Calendar Availability": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Human Escalation Tool": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Delete Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bc055219b8ddb8cb6a3ed41fcda359f13436b13a927934d06acc0a1be80d63bb"
  },
  "tags": [
    {
      "updatedAt": "2026-01-09T20:58:28.731Z",
      "createdAt": "2026-01-09T20:58:28.731Z",
      "id": "10",
      "name": "main"
    },
    {
      "updatedAt": "2026-01-09T22:13:51.035Z",
      "createdAt": "2026-01-09T22:13:51.035Z",
      "id": "GEOf7qigu1JiMPtR",
      "name": "multi-tenant"
    },
    {
      "updatedAt": "2026-01-09T22:13:51.036Z",
      "createdAt": "2026-01-09T22:13:51.036Z",
      "id": "egXnX2gjJK2KVVbN",
      "name": "optimized"
    },
    {
      "updatedAt": "2026-01-09T20:58:28.731Z",
      "createdAt": "2026-01-09T20:58:28.731Z",
      "id": "11",
      "name": "production"
    }
  ]
}