{
  "name": "01 - WhatsApp Main Handler",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp-main",
        "options": {}
      },
      "id": "4fb9f0b7-fe99-4263-9ac1-78db8c5dea04",
      "name": "WhatsApp Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [
        0,
        400
      ],
      "typeVersion": 2,
      "webhookId": "whatsapp-main-handler"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "{{TENANT_CONFIG_LOADER_WORKFLOW_ID}}",
          "mode": "list",
          "cachedResultUrl": "/workflow/{{TENANT_CONFIG_LOADER_WORKFLOW_ID}}",
          "cachedResultName": "Tenant Config Loader"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "b456e280-fc42-41c7-abfa-a36ddd84e2e7",
      "name": "Load Tenant Config",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        240,
        400
      ],
      "typeVersion": 1.2,
      "notes": "üîë Carrega configura√ß√£o espec√≠fica do tenant do banco de dados\n\n**Entrada**: Webhook payload com `body.instance` ou `instance_name`\n**Sa√≠da**: \n- `tenant_config` - Configura√ß√£o completa do tenant\n- `tenant_id` - UUID do tenant\n- `services_catalog` - Cat√°logo formatado de servi√ßos\n\n**Uso**: Chamado automaticamente antes de processar mensagens"
    },
    {
      "parameters": {
        "jsCode": "// Parse webhook data and detect message type intelligently\n// Handle different payload structures from Evolution API and Tenant Config Loader\nconst body = $json.body || $json;\nconst data = body?.data || body;\n\n// Try multiple paths to find message structure\nconst messageObj = body?.data?.message || body?.message || data?.message || {};\nconst keyObj = body?.data?.key || body?.key || data?.key || {};\n\n// Detect message type based on available fields\nlet messageType = body?.data?.messageType || data?.messageType || messageObj?.messageType || null;\n\n// If messageType not found, infer from message structure\nif (!messageType) {\n  if (messageObj.conversation || messageObj.extendedTextMessage?.text) {\n    messageType = 'conversation';\n  } else if (messageObj.imageMessage || body?.data?.message?.imageMessage) {\n    messageType = 'imageMessage';\n  } else if (messageObj.audioMessage || body?.data?.message?.audioMessage) {\n    messageType = 'audioMessage';\n  } else if (messageObj.videoMessage) {\n    messageType = 'videoMessage';\n  } else if (messageObj.documentMessage) {\n    messageType = 'documentMessage';\n  } else {\n    // Default to conversation if we have message_text or any text content\n    messageType = 'conversation';\n  }\n}\n\n// Extract message text (try multiple paths)\nconst messageText = messageObj.conversation\n  || messageObj.extendedTextMessage?.text\n  || body?.data?.message?.conversation\n  || body?.data?.message?.extendedTextMessage?.text\n  || messageObj.imageMessage?.caption\n  || '';\n\n// Extract remote JID (handle different formats)\nconst remoteJid = keyObj.remoteJid\n  || data?.remoteJid\n  || body?.remoteJid\n  || body?.from\n  || body?.data?.key?.remoteJid\n  || '';\n\n// Extract image URL\nconst imageMessage = messageObj.imageMessage || body?.data?.message?.imageMessage || {};\nconst imageUrl = imageMessage.url || imageMessage.directPath || '';\n\n// Extract audio URL\nconst audioMessage = messageObj.audioMessage || body?.data?.message?.audioMessage || {};\nconst audioUrl = audioMessage.url || audioMessage.directPath || '';\n\nreturn {\n  message_type: messageType,\n  remote_jid: remoteJid,\n  message_text: messageText,\n  message_id: keyObj.id || data?.id || body?.id || body?.data?.key?.id || '',\n  push_name: data?.pushName || body?.pushName || body?.senderName || data?.push_name || body?.data?.pushName || 'Paciente',\n  image_url: imageUrl,\n  audio_url: audioUrl,\n  tenant_config: $json.tenant_config,\n  tenant_id: $json.tenant_id,\n  services_catalog: $json.services_catalog,\n  // Preserve original for debugging\n  original_body: body,\n  original_data: data\n};"
      },
      "id": "9938f5c9-ec40-46c4-a876-253f2d38f828",
      "name": "Parse Webhook Data",
      "type": "n8n-nodes-base.code",
      "position": [
        480,
        400
      ],
      "typeVersion": 2,
      "notes": "üîß Detecta inteligentemente o tipo de mensagem e faz parse dos dados do webhook\n\n**Suporta**:\n- Mensagens de texto (conversation)\n- Mensagens de imagem (imageMessage)\n- Mensagens de √°udio (audioMessage)\n- Mensagens de v√≠deo (videoMessage)\n- Mensagens de documento (documentMessage)\n\n**Extrai**:\n- `message_type` - Tipo da mensagem\n- `remote_jid` - ID do remetente\n- `message_text` - Texto da mensagem\n- `image_url` / `audio_url` - URLs de m√≠dia"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "conversation",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "text"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "imageMessage",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "image"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.message_type }}",
                    "rightValue": "audioMessage",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "audio"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "3021e7da-e056-4046-a754-75b19176e351",
      "name": "Message Type Switch",
      "type": "n8n-nodes-base.switch",
      "position": [
        720,
        400
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "audio-feature-check",
              "leftValue": "={{ $('Load Tenant Config').item.json.tenant_config?.features?.audio_transcription }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "check-audio-feature",
      "name": "Check Audio Feature",
      "type": "n8n-nodes-base.if",
      "position": [
        960,
        600
      ],
      "typeVersion": 2.1
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ 'Audio Transcription Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "instance_name": "={{ $('Parse Webhook Data').item.json.instance_name }}",
            "message_id": "={{ $('Parse Webhook Data').item.json.message_id }}"
          }
        },
        "options": {}
      },
      "id": "8d925187-11dc-4228-a87e-9dfdcb3fe53c",
      "name": "Process Audio",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        1080,
        550
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "transcribed_text",
              "name": "transcribed_text",
              "type": "string",
              "value": "={{ $('Parse Webhook Data').item.json.message_text || '' }}"
            },
            {
              "id": "feature_disabled_message",
              "name": "feature_disabled_message",
              "type": "string",
              "value": "Desculpe, o processamento de √°udio n√£o est√° dispon√≠vel para esta cl√≠nica. Por favor, envie sua mensagem por texto."
            }
          ]
        }
      },
      "id": "audio-not-available",
      "name": "Audio Not Available",
      "type": "n8n-nodes-base.set",
      "position": [
        1080,
        700
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "image-feature-check",
              "leftValue": "={{ $('Load Tenant Config').item.json.tenant_config?.features?.image_ocr }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "check-image-feature",
      "name": "Check Image Feature",
      "type": "n8n-nodes-base.if",
      "position": [
        960,
        250
      ],
      "typeVersion": 2.1
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ 'Image OCR Tool' }}",
          "mode": "list"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "image_url": "={{ $('Parse Webhook Data').item.json.image_url }}"
          }
        },
        "options": {}
      },
      "id": "8ac9b17c-a1e0-4c4f-a8be-baaca8c4e8f9",
      "name": "Process Image",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        1080,
        200
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "transcribed_text",
              "name": "transcribed_text",
              "type": "string",
              "value": "={{ $('Parse Webhook Data').item.json.message_text || '' }}"
            },
            {
              "id": "feature_disabled_message",
              "name": "feature_disabled_message",
              "type": "string",
              "value": "Desculpe, o processamento de imagens n√£o est√° dispon√≠vel para esta cl√≠nica. Por favor, envie sua mensagem por texto."
            }
          ]
        }
      },
      "id": "image-not-available",
      "name": "Image Not Available",
      "type": "n8n-nodes-base.set",
      "position": [
        1080,
        350
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM get_or_create_conversation_state('{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid, '{{ $('Parse Webhook Data').item.json.remote_jid }}'::varchar);",
        "options": {}
      },
      "id": "cd83c3c8-d0b9-414b-ac4f-7315bba5213f",
      "name": "Get Conversation State",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1200,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM transition_conversation_state(\n  '{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid,\n  '{{ $('Parse Webhook Data').item.json.remote_jid }}',\n  '{{ $('Parse Webhook Data').item.json.message_text }}'\n);",
        "options": {}
      },
      "id": "6d598e7d-3d0d-4a9c-b411-a39d2b128111",
      "name": "Transition State",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1440,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "requires-ai",
              "leftValue": "={{ $json.requires_ai }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "398f328b-001d-4613-be4e-feae08e8311e",
      "name": "Requires AI?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1680,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===================================\n// INTENT CLASSIFIER\n// Cost: ~$0 (no AI call)\n// Latency: ~10ms\n// ===================================\n\nconst text = ($json.message_text || $json.transcribed_text || '').trim();\nconst textLower = text.toLowerCase();\nconst tenantId = $json.tenant_id;\n\n// PRIORITY: Numbered menu options (1, 2, 3, 4) - handled first to avoid AI\n// These map directly to FAQ entries\nconst menuPatterns = {\n  '1': /^1$|^um$/i,\n  '2': /^2$|^dois$/i,\n  '3': /^3$|^tr[√™e]s$/i,\n  '4': /^4$|^quatro$/i\n};\n\n// Check for menu number first (highest priority)\nlet intent = 'complex'; // Default to AI processing\nlet confidence = 0;\nlet menuNumber = null;\nlet serviceNumber = null;\n\nfor (const [num, pattern] of Object.entries(menuPatterns)) {\n  if (pattern.test(text)) {\n    menuNumber = num;\n    // Map menu number to intent for FAQ lookup\n    const menuToIntent = {\n      '1': 'appointment',\n      '2': 'reschedule',\n      '3': 'info',\n      '4': 'hours_location'\n    };\n    intent = menuToIntent[num] || 'complex';\n    confidence = 0.95; // Very high confidence for menu selections\n    break;\n  }\n}\n\n// If not a menu number, check if it's a service catalog number (5 or higher)\nif (!menuNumber) {\n  // Check if text is a pure number (5 or higher) - likely a service selection\n  const numericMatch = text.match(/^(\\d+)$/);\n  if (numericMatch) {\n    const num = parseInt(numericMatch[1], 10);\n    if (num >= 5) {\n      // This is likely a service catalog number - process without AI\n      serviceNumber = num;\n      intent = 'service_selection';\n      confidence = 0.95;\n    }\n  }\n}\n\n// If not a menu number or service number, check other patterns\nif (!menuNumber && !serviceNumber) {\n  const patterns = {\n    greeting: /^(oi|ol√°|ola|bom dia|boa tarde|boa noite|hey|hello)/,\n    hours: /(hor√°rio|horario|hora|abre|fecha|aberto|funciona|atende)/,\n    location: /(endere√ßo|endereco|onde|localiza√ß√£o|localizacao|fica|chegar)/,\n    appointment: /(agendar|marcar|consulta|hor√°rio dispon√≠vel|horario disponivel|vaga)/,\n    cancel: /(cancelar|desmarcar|n√£o vou|nao vou)/,\n    reschedule: /(remarcar|mudar|alterar|trocar dia|trocar hora)/,\n    confirmation: /(sim|confirmo|confirmar|ok|tudo bem|pode ser)/,\n    help: /(ajuda|help|socorro|n√£o entendi|nao entendi)/\n  };\n\n  for (const [intentName, pattern] of Object.entries(patterns)) {\n    if (pattern.test(textLower)) {\n      intent = intentName;\n      confidence = 0.9;\n      break;\n    }\n  }\n}\n\n// Extract dates if present (simple regex for pt-BR)\nconst datePatterns = [\n  /\\d{1,2}[\\/\\-]\\d{1,2}(?:[\\/\\-]\\d{2,4})?/, // 10/01 or 10/01/2025\n  /(pr√≥xima|proxima|segunda|ter√ßa|terca|quarta|quinta|sexta|s√°bado|sabado|domingo)/,\n  /(amanh√£|amanha|hoje|depois de amanh√£|depois de amanha)/\n];\n\nlet extractedDate = null;\nfor (const pattern of datePatterns) {\n  const match = textLower.match(pattern);\n  if (match) {\n    extractedDate = match[0];\n    break;\n  }\n}\n\nreturn {\n  ...$json,\n  intent,\n  confidence,\n  menu_number: menuNumber, // Store menu number if selected\n  service_number: serviceNumber, // Store service catalog number if selected (5+)\n  extracted_date: extractedDate,\n  requires_ai: intent === 'complex' || (intent !== 'service_selection' && confidence < 0.8),\n  // For FAQ query: use menu number directly if present, otherwise use normalized text\n  message_text_normalized: menuNumber ? menuNumber : textLower.trim(),\n  intent_for_faq: intent || ''\n};"
      },
      "id": "6737fe7d-4d89-4364-9521-30cdad1457c7",
      "name": "Intent Classifier",
      "type": "n8n-nodes-base.code",
      "position": [
        1920,
        100
      ],
      "typeVersion": 2,
      "notes": "‚ö° Classifica√ß√£o r√°pida de inten√ß√£o sem chamada de IA (~10ms)\n\n**Detecta**:\n- Sauda√ß√µes (oi, ol√°, bom dia)\n- Hor√°rios (hor√°rio, abre, fecha)\n- Localiza√ß√£o (endere√ßo, onde fica)\n- Agendamento (agendar, marcar, consulta)\n- Cancelamento (cancelar, desmarcar)\n- Reagendamento (remarcar, mudar)\n- Confirma√ß√£o (sim, confirmo, ok)\n- Sele√ß√£o de menu (1, 2, 3, 4)\n- Sele√ß√£o de servi√ßo (5+)\n\n**Prioridade**: N√∫meros de menu e cat√°logo s√£o processados primeiro (sem IA)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Check FAQ cache first\n-- IMPORTANT: Always returns at least one row to keep workflow running\n-- Uses message_text_normalized and intent_for_faq from Intent Classifier\n-- Falls back to message_text and intent if normalized fields not available\nWITH faq_result AS (\n  SELECT \n    answer,\n    view_count,\n    question_original,\n    intent\n  FROM tenant_faq\n  WHERE tenant_id = '{{ $json.tenant_id }}'::UUID\n    AND is_active = true\n    AND (\n      question_normalized ILIKE '%{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}%'\n      OR ('{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}' != '' AND keywords @> ARRAY['{{ $json.message_text_normalized || ($json.message_text || \"\").toLowerCase() }}'])\n      OR ('{{ $json.intent_for_faq || $json.intent || \"\" }}' != '' AND intent = '{{ $json.intent_for_faq || $json.intent || \"\" }}')\n    )\n  ORDER BY view_count DESC, COALESCE(last_used_at, created_at) DESC\n  LIMIT 1\n)\nSELECT * FROM faq_result\nUNION ALL\nSELECT NULL::TEXT as answer, 0::INTEGER as view_count, NULL::TEXT as question_original, NULL::TEXT as intent\nWHERE NOT EXISTS (SELECT 1 FROM faq_result)\nLIMIT 1;",
        "options": {}
      },
      "id": "1f3bb3a1-cba9-4b71-b474-a5c518ef12bd",
      "name": "Check FAQ Cache",
      "type": "n8n-nodes-base.postgres",
      "position": [
        2160,
        100
      ],
      "typeVersion": 2.4,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Verifica se podemos responder do cache de FAQs\n\n**Estrat√©gia**:\n- Busca por texto normalizado\n- Busca por palavras-chave\n- Busca por inten√ß√£o\n- Ordena por `view_count` e `last_used_at`\n\n**Retorna**:\n- `answer` - Resposta do FAQ (se encontrado)\n- `view_count` - Quantas vezes foi usado\n- `faq_found` - Boolean indicando se encontrou\n\n**Performance**: ~50ms vs ~800ms com IA"
    },
    {
      "parameters": {
        "jsCode": "// ===================================\n// MERGE FAQ + TEMPLATE RESOLVER\n// 3-layer defense: Template ‚Üí FAQ ‚Üí AI\n// ===================================\nconst intentClassifierData = $('Intent Classifier').first()?.json || {};\nconst faqResult = $json || {};\n\n// Layer 1: Check if we have a template for this intent\n// Map detected intents to template_keys in response_templates table\nconst intentToTemplate = {\n  'greeting': 'greeting_new',\n  'hours': 'hours_location',\n  'location': 'hours_location',\n  'hours_location': 'hours_location',\n  'help': 'invalid_option',\n  'confirmation': null, // Needs context from state machine\n  'cancel': null, // Needs AI for specific appointment\n  'reschedule': null, // Needs AI for specific appointment\n  'appointment': null, // Needs AI to process scheduling\n  'complex': null // Always AI\n};\n\nconst intent = intentClassifierData.intent || 'complex';\nconst templateKey = intentToTemplate[intent] || null;\nconst requiresAi = intentClassifierData.requires_ai;\nconst hasFaqAnswer = !!(faqResult.answer && faqResult.answer.toString().trim() !== '');\n\n// Determine if this can be resolved without AI\n// Priority: FAQ answer > Template > AI\nlet canSkipAi = false;\nlet resolvedAnswer = null;\n\nif (hasFaqAnswer) {\n  // FAQ cache hit - use it directly\n  canSkipAi = true;\n  resolvedAnswer = faqResult.answer;\n} else if (templateKey && !requiresAi) {\n  // Known intent with template available - will be resolved by template query\n  canSkipAi = true;\n  resolvedAnswer = null; // Will be filled by Resolve Template node\n}\n\nreturn {\n  // Preserve all Intent Classifier fields\n  ...intentClassifierData,\n  // FAQ result fields\n  answer: faqResult.answer || null,\n  faq_view_count: faqResult.view_count || 0,\n  faq_question_original: faqResult.question_original || null,\n  faq_intent: faqResult.intent || null,\n  faq_found: hasFaqAnswer,\n  // Template resolution fields\n  template_key: templateKey,\n  can_skip_ai: canSkipAi,\n  resolved_answer: resolvedAnswer,\n  // Explicit AI flag from Intent Classifier\n  requires_ai: requiresAi\n};"
      },
      "id": "b5325df8-4671-4a44-ae97-7ac145e46542",
      "name": "Merge FAQ Result",
      "type": "n8n-nodes-base.code",
      "position": [
        2400,
        100
      ],
      "typeVersion": 2,
      "notes": "üîß 3-Layer Defense: Template ‚Üí FAQ ‚Üí AI\n\nMaps intents to response_templates:\n- greeting ‚Üí greeting_new\n- hours/location ‚Üí hours_location\n- help ‚Üí invalid_option\n\nOnly sends to AI if:\n- No FAQ cache hit\n- No template available\n- Intent is 'complex'"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.requires_ai === true && $json.faq_found !== true && !$json.template_key }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "50d2bee4-f549-4416-8aa2-cd559300d702",
      "name": "Needs AI?",
      "type": "n8n-nodes-base.if",
      "position": [
        2640,
        100
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Build dynamic system prompt with services catalog\nconst basePrompt = $json.tenant_config?.system_prompt_patient || '';\nconst servicesCatalog = $json.services_catalog || 'Nenhum servi√ßo cadastrado.';\n\n// Replace {{ $json.services_catalog }} placeholder with actual catalog\nconst systemPrompt = basePrompt.replace(\n  /\\{\\{ \\$json\\.services_catalog \\}\\}/g,\n  servicesCatalog\n);\n\n// CRITICAL: Preserve tenant_id and all essential fields for tools\nreturn {\n  ...$json,\n  system_prompt_with_catalog: systemPrompt,\n  // Explicitly preserve tenant_id (critical for tool workflows)\n  tenant_id: $json.tenant_id || $('Merge FAQ Result').item.json.tenant_id || $('Parse Webhook Data').item.json.tenant_id || null,\n  // Preserve tenant_config for reference\n  tenant_config: $json.tenant_config || $('Merge FAQ Result').item.json.tenant_config || $('Parse Webhook Data').item.json.tenant_config || null\n};"
      },
      "id": "83200162-d2fe-4101-97b9-d7e7279ea72c",
      "name": "Build Prompt with Catalog",
      "type": "n8n-nodes-base.code",
      "position": [
        2880,
        -100
      ],
      "typeVersion": 2,
      "notes": "üîß Injects services catalog into prompt dynamically"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message_text || $json.transcribed_text || $json.extracted_text }}",
        "options": {
          "systemMessage": "={{ $json.system_prompt_with_catalog || $json.tenant_config.system_prompt_patient }}"
        }
      },
      "id": "43783b06-32eb-49cb-9b7a-97a0d16eb059",
      "name": "Patient Assistant Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        3360,
        -100
      ],
      "typeVersion": 1.8,
      "notes": "ü§ñ Agente de IA para pacientes - chamado apenas quando FAQ n√£o tem resposta\n\n**Modelo**: Mistral 7B (via OpenRouter)\n**Mem√≥ria**: 5 mensagens (reduzido para economia)\n**Ferramentas**:\n- FindProfessionals - Busca profissionais por servi√ßo\n- ListCalendarEvents - Lista eventos para reagendar/cancelar\n- CheckCalendarAvailability - Consulta hor√°rios dispon√≠veis\n- CreateCalendarEvent - Cria agendamento\n- UpdateCalendarEvent - Reagenda (atualiza) agendamento existente\n- DeleteCalendarEvent - Cancela (exclui) agendamento\n- CallToHuman - Escala√ß√£o para humano\n\n**Prompt**: Injetado dinamicamente com cat√°logo de servi√ßos do tenant"
    },
    {
      "parameters": {
        "model": "openai/gpt-oss-120b:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2880,
        100
      ],
      "id": "7a3093e0-266a-4be9-9958-97f89b3ccdee",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "{{OPENROUTER_CREDENTIAL_ID}}",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.tenant_id }}_{{ $json.remote_jid }}"
      },
      "id": "e651bb83-6961-4662-aeef-f1d619e33239",
      "name": "Postgres Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "position": [
        3000,
        100
      ],
      "typeVersion": 1.3,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Reduced window: 5 instead of 10"
    },
    {
      "parameters": {
        "name": "FindProfessionals",
        "description": "Busca profissionais que oferecem um servi√ßo espec√≠fico. Use quando o cliente escolher um servi√ßo para verificar quantos profissionais oferecem e seus pre√ßos/dura√ß√µes. Retorna lista de profissionais com calendar_id de cada um. IMPORTANTE: Esta ferramenta recebe tenant_id automaticamente do contexto - voc√™ s√≥ precisa fornecer o service_name.",
        "workflowId": {
          "__rl": true,
          "value": "FVyU7WmQX73SHQcs",
          "mode": "id",
          "cachedResultName": "Find Professionals Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $('Parse Webhook Data').first()?.json?.tenant_id || $('Build Prompt with Catalog').first()?.json?.tenant_id || $('Merge FAQ Result').first()?.json?.tenant_id || '' }}",
            "service_name": "={{ $fromAI('service_name', '', 'string') }}"
          }
        }
      },
      "id": "4f68d8f7-0d76-40b0-b260-137572faf4ff",
      "name": "Find Professionals Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3120,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üîç Busca profissionais que oferecem um servi√ßo"
    },
    {
      "parameters": {
        "name": "ListCalendarEvents",
        "description": "Lista eventos existentes de um calend√°rio do Google Calendar. Use ANTES de reagendar ou cancelar para encontrar o event_id do agendamento. Retorna todos os eventos no per√≠odo especificado, incluindo event_id, summary, start e end. IMPORTANTE: Use o calendar_id do profissional. Para encontrar agendamentos do paciente, busque por nome ou telefone no summary/description dos eventos retornados.",
        "workflowId": {
          "__rl": true,
          "value": "wFmcRycLeCemWSw1",
          "mode": "id",
          "cachedResultName": "Google Calendar List Events Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "time_min": "={{ $fromAI('time_min', new Date().toISOString(), 'string') }}",
            "time_max": "={{ $fromAI('time_max', new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), 'string') }}"
          }
        }
      },
      "id": "b6936c89-8331-4b27-94a5-6fbd5183e59e",
      "name": "List Calendar Events",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3248,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üìã Lista eventos para reagendar/cancelar"
    },
    {
      "parameters": {
        "name": "CheckCalendarAvailability",
        "description": "Consulta hor√°rios dispon√≠veis em um calend√°rio do Google Calendar. Use quando o cliente escolher um profissional e servi√ßo. Retorna as 10 op√ß√µes de hor√°rio mais pr√≥ximas, considerando a dura√ß√£o do procedimento. IMPORTANTE: Use o calendar_id e duration_minutes retornados por FindProfessionals. O start_time deve ser a partir de agora (data/hora atual). O end_time deve ser 7 dias no futuro. Retorna apenas as 10 op√ß√µes mais pr√≥ximas que t√™m tempo suficiente para o procedimento.",
        "workflowId": {
          "__rl": true,
          "value": "iaQfqBe29sPuLxLS",
          "mode": "id",
          "cachedResultName": "Google Calendar Availability Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "start_time": "={{ $fromAI('start_time', new Date().toISOString(), 'string') }}",
            "end_time": "={{ $fromAI('end_time', new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), 'string') }}",
            "duration_minutes": "={{ $fromAI('duration_minutes', 30, 'number') }}"
          }
        }
      },
      "id": "7801dead-b34f-4390-a3ee-1baa3f8c22ec",
      "name": "Check Calendar Availability",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3376,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Consulta disponibilidade usando Google Calendar API"
    },
    {
      "parameters": {
        "name": "CreateCalendarEvent",
        "description": "Cria um evento no Google Calendar. Use quando o cliente escolher um hor√°rio. IMPORTANTE: Use o calendar_id do profissional escolhido. Inclua na descri√ß√£o: nome completo, data de nascimento, telefone (extrair de remote_jid do WhatsApp) e servi√ßo. N√ÉO solicite telefone do cliente - j√° est√° dispon√≠vel via WhatsApp.",
        "workflowId": {
          "__rl": true,
          "value": "dVQB3Xn0AGmOrYfj",
          "mode": "id",
          "cachedResultName": "Google Calendar Create Event Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "summary": "={{ $fromAI('summary', '', 'string') }}",
            "start": "={{ $fromAI('start', '', 'string') }}",
            "end": "={{ $fromAI('end', '', 'string') }}",
            "description": "={{ $fromAI('description', '', 'string') }}"
          }
        }
      },
      "id": "b951b788-1c1e-465e-b12f-168d17b5f9aa",
      "name": "Create Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3504,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Cria evento usando Google Calendar API"
    },
    {
      "parameters": {
        "name": "CallToHuman",
        "description": "Use essa ferramenta para escalar atendimento para humano em casos urgentes ou complexos",
        "workflowId": {
          "__rl": true,
          "value": "mrF56wuFz0GHFTve",
          "mode": "id",
          "cachedResultName": "Call to Human Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "patient_name": "={{ $fromAI('patient_name', '', 'string') }}",
            "phone_number": "={{ $json.remote_jid }}",
            "last_message": "={{ $fromAI('last_message', '', 'string') }}",
            "telegram_chat_id": "={{ $json.tenant_config.telegram_internal_chat_id }}",
            "instance_name": "={{ $json.tenant_config.evolution_instance_name }}",
            "reason": "={{ $fromAI('reason', 'Escala√ß√£o solicitada pelo paciente', 'string') }}"
          }
        }
      },
      "id": "b63b3e62-a589-4757-a2b3-dc7860d9c954",
      "name": "Human Escalation Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3632,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üìû Escala√ß√£o para atendimento humano\n\n**Multi-tenant**: Usa telegram_chat_id e instance_name do tenant"
    },
    {
      "parameters": {
        "name": "UpdateCalendarEvent",
        "description": "Atualiza (reagenda) um evento existente no Google Calendar. Use quando o cliente quiser mudar o hor√°rio de um agendamento existente. Requer: calendar_id do profissional, event_id do agendamento, novo start e end. Use ListCalendarEvents primeiro para encontrar o event_id do agendamento a ser reagendado.",
        "workflowId": {
          "__rl": true,
          "value": "d5WDpqt1thSXUO04",
          "mode": "id",
          "cachedResultName": "Google Calendar Update Event Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "event_id": "={{ $fromAI('event_id', '', 'string') }}",
            "start": "={{ $fromAI('start', '', 'string') }}",
            "end": "={{ $fromAI('end', '', 'string') }}",
            "summary": "={{ $fromAI('summary', '', 'string') }}",
            "description": "={{ $fromAI('description', '', 'string') }}"
          }
        }
      },
      "id": "c8229d49-c1f9-4eba-9cde-1cf1dd7e5711",
      "name": "Update Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3760,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üìÖ Reagenda evento existente no Google Calendar"
    },
    {
      "parameters": {
        "name": "DeleteCalendarEvent",
        "description": "Cancela (exclui) um agendamento do Google Calendar. Use quando o cliente confirmar que deseja cancelar um agendamento. Requer: calendar_id do profissional e event_id do agendamento. Use ListCalendarEvents primeiro para encontrar o event_id. O sistema enviar√° um alerta para a equipe automaticamente.",
        "workflowId": {
          "__rl": true,
          "value": "veWDM8tzwykSWV4m",
          "mode": "id",
          "cachedResultName": "Google Calendar Delete Event Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id }}",
            "calendar_id": "={{ $fromAI('calendar_id', '', 'string') }}",
            "event_id": "={{ $fromAI('event_id', '', 'string') }}",
            "patient_name": "={{ $fromAI('patient_name', '', 'string') }}",
            "patient_phone": "={{ $json.remote_jid }}",
            "reason": "={{ $fromAI('reason', 'Cancelamento solicitado pelo paciente', 'string') }}",
            "telegram_chat_id": "={{ $json.tenant_config.telegram_internal_chat_id }}",
            "send_alert": true
          }
        }
      },
      "id": "85f455a1-c707-42a1-95bf-3abfcb4329c0",
      "name": "Delete Calendar Event",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        3888,
        100
      ],
      "typeVersion": 2.1,
      "notes": "üö´ Cancela agendamento e notifica equipe"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "service_selection",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "service_selection"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.template_key }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "notEquals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "template"
            },
            {
              "conditions": {
                "options": {
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.faq_found }}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "true"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "faq"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "6497a215-27fc-4a8b-b0f7-ffaa1d598991",
      "name": "No-AI Router",
      "type": "n8n-nodes-base.switch",
      "position": [
        2880,
        300
      ],
      "typeVersion": 3.2,
      "notes": "üîÄ Routes non-AI responses:\n\n1. service_selection ‚Üí Get Service by Number\n2. template ‚Üí Resolve Template (DB)\n3. faq ‚Üí Use FAQ Answer\n4. fallback ‚Üí Build Prompt (AI)"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "formatted_text",
              "name": "formatted_text",
              "type": "string",
              "value": "={{ $json.answer }}"
            }
          ]
        },
        "options": {}
      },
      "id": "bb654199-6e0c-4d52-827a-283d8ea29c4f",
      "name": "Use FAQ Answer",
      "type": "n8n-nodes-base.set",
      "position": [
        3360,
        500
      ],
      "typeVersion": 3.4,
      "notes": "‚úÖ Skip AI entirely - use cached answer"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT get_template_response(\n  '{{ $json.tenant_id }}'::UUID,\n  '{{ $json.template_key }}',\n  jsonb_build_object(\n    'patient_name', '{{ $json.push_name || \"Paciente\" }}',\n    'clinic_name', '{{ ($json.tenant_config && $json.tenant_config.clinic_name) || \"nossa cl√≠nica\" }}',\n    'address', '{{ ($json.tenant_config && $json.tenant_config.clinic_address) || \"\" }}',\n    'business_hours', '{{ ($json.tenant_config && $json.tenant_config.hours_start) || \"08:00\" }}' || ' √†s ' || '{{ ($json.tenant_config && $json.tenant_config.hours_end) || \"19:00\" }}' || ' ({{ ($json.tenant_config && $json.tenant_config.days_open_display) || \"Segunda-S√°bado\" }})',\n    'phone', '{{ ($json.tenant_config && $json.tenant_config.clinic_phone) || \"\" }}'\n  )\n) AS template_response;",
        "options": {}
      },
      "id": "a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d",
      "name": "Resolve Template",
      "type": "n8n-nodes-base.postgres",
      "position": [
        3120,
        400
      ],
      "typeVersion": 2.4,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üìã Resolve response template from DB (no AI)\n\nCalls get_template_response() with:\n- tenant_id\n- template_key (from Merge FAQ Result)\n- variables (patient_name, clinic_name, etc.)\n\nCost: $0 | Latency: ~20ms"
    },
    {
      "parameters": {
        "jsCode": "// Use template response OR fallback to FAQ answer\nconst mergeData = $('Merge FAQ Result').first()?.json || {};\nconst templateResponse = $json.template_response || null;\nconst faqAnswer = mergeData.answer || null;\n\n// Priority: Template > FAQ\nconst finalAnswer = templateResponse || faqAnswer || 'Desculpe, n√£o entendi. Pode reformular sua pergunta?';\n\nreturn {\n  ...mergeData,\n  formatted_text: finalAnswer\n};"
      },
      "id": "d4e5f6a7-b8c9-4d0e-1f2a-3b4c5d6e7f8a",
      "name": "Use Template Answer",
      "type": "n8n-nodes-base.code",
      "position": [
        3360,
        400
      ],
      "typeVersion": 2,
      "notes": "‚úÖ Skip AI ‚Äî use resolved template response\n\nPriority: Template > FAQ > fallback"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT get_template_response(\n  CAST('{{ $('Parse Webhook Data').item.json.tenant_id }}' AS uuid),\n  CAST('{{ $('Transition State').item.json.template_key || \"\" }}' AS varchar(100)),\n  CAST('{{ JSON.stringify({\n    \"patient_name\": $('Parse Webhook Data').item.json.push_name || \"Cliente\",\n    \"clinic_name\": $('Parse Webhook Data').item.json.tenant_config.clinic_name\n  }) }}' AS jsonb)\n) as response_text;",
        "options": {}
      },
      "id": "515fb157-9282-40e3-818b-bc627d6b15f1",
      "name": "Get Template Response",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1920,
        500
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "is-invalid-option",
              "leftValue": "={{ $('Transition State').item.json.template_key }}",
              "rightValue": "invalid_option",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "882f3a5e-8ea4-4d18-bf4a-09eb60b6e54f",
      "name": "Needs Available Options?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2160,
        500
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  valid_inputs,\n  description\nFROM state_definitions\nWHERE state_name = '{{ $('Transition State').item.json.new_state }}';",
        "options": {}
      },
      "id": "8074d168-0cee-4d4b-8104-afb324875970",
      "name": "Get Available Options",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2400,
        600
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "needs-data",
              "leftValue": "={{ $('Transition State').item.json.new_state }}",
              "rightValue": "awaiting_service",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "is-invalid-option-template",
              "leftValue": "={{ $('Transition State').item.json.template_key }}",
              "rightValue": "invalid_option",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "d32d6147-f837-4ee7-8a99-3699b1ad2bf0",
      "name": "Needs Dynamic Data?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2640,
        500
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT get_services_catalog_for_prompt('{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid) as service_list;",
        "options": {}
      },
      "id": "6ef14d93-f71f-4216-a208-68497a56e000",
      "name": "Get Services List",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2880,
        500
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge template with dynamic data\nconst template = $('Get Template Response').item.json.response_text;\nconst newState = $('Transition State').item.json.new_state;\nconst templateKey = $('Transition State').item.json.template_key;\n\nlet finalResponse = template;\n\n// Replace dynamic placeholders based on state\nif (newState === 'awaiting_service' && $('Get Services List').item) {\n  finalResponse = finalResponse.replace(\n    '{{service_list}}',\n    $('Get Services List').item.json.service_list || ''\n  );\n}\n\n// Add professional list if needed\nif (newState === 'awaiting_professional' && $input.item.json.professional_list) {\n  finalResponse = finalResponse.replace(\n    '{{professional_list}}',\n    $input.item.json.professional_list\n  );\n}\n\n// Replace available_options placeholder for invalid_option template\nif (templateKey === 'invalid_option' && finalResponse.includes('{{available_options}}')) {\n  let availableOptions = '';\n  \n  // Map of state actions to human-readable descriptions\n  const actionDescriptions = {\n    'schedule': 'Agendar consulta',\n    'reschedule': 'Reagendar consulta',\n    'cancel': 'Cancelar consulta',\n    'services_info': 'Informa√ß√µes sobre servi√ßos',\n    'hours_location': 'Hor√°rio e localiza√ß√£o',\n    'select_service': 'Selecionar servi√ßo',\n    'select_professional': 'Selecionar profissional',\n    'select_slot': 'Selecionar hor√°rio',\n    'confirmed': 'Confirmar',\n    'cancelled': 'Cancelar',\n    'initial': 'Voltar ao menu principal'\n  };\n  \n  // Try to get options from Get Available Options node\n  if ($('Get Available Options') && $('Get Available Options').item) {\n    let validInputs = $('Get Available Options').item.json.valid_inputs;\n    \n    // Parse JSON if it's a string\n    if (typeof validInputs === 'string') {\n      try {\n        validInputs = JSON.parse(validInputs);\n      } catch (e) {\n        validInputs = null;\n      }\n    }\n    \n    if (validInputs && typeof validInputs === 'object') {\n      // Get the state definition to understand next_states mapping\n      const stateDef = $('Get Available Options').item.json;\n      \n      // Extract numeric keys and sort them\n      const numericKeys = Object.keys(validInputs)\n        .filter(key => !isNaN(parseInt(key)) && key !== 'number' && key !== 'voltar')\n        .map(key => parseInt(key))\n        .sort((a, b) => a - b);\n      \n      if (numericKeys.length > 0) {\n        const emojis = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£'];\n        numericKeys.forEach((num, index) => {\n          const numKey = num.toString();\n          const action = validInputs[numKey];\n          const description = actionDescriptions[action] || action || `Op√ß√£o ${num}`;\n          const emoji = emojis[index] || `${index + 1}Ô∏è‚É£`;\n          availableOptions += `${emoji} ${description}\\n`;\n        });\n        availableOptions = availableOptions.trim();\n      } else {\n        // If no numbered options, show text options with descriptions\n        const textKeys = Object.keys(validInputs)\n          .filter(key => key !== 'number' && key !== 'voltar');\n        if (textKeys.length > 0) {\n          textKeys.forEach((key, index) => {\n            const action = validInputs[key];\n            const description = actionDescriptions[action] || action || key;\n            availableOptions += `${index + 1}Ô∏è‚É£ ${description}\\n`;\n          });\n          availableOptions = availableOptions.trim();\n        }\n      }\n    }\n  }\n  \n  // If still no options, provide a generic message based on state\n  if (!availableOptions) {\n    if (newState === 'initial') {\n      availableOptions = '1Ô∏è‚É£ Agendar consulta\\n2Ô∏è‚É£ Reagendar consulta\\n3Ô∏è‚É£ Cancelar consulta\\n4Ô∏è‚É£ Informa√ß√µes sobre servi√ßos\\n5Ô∏è‚É£ Hor√°rio e localiza√ß√£o';\n    } else {\n      availableOptions = 'Por favor, digite o n√∫mero da op√ß√£o desejada.';\n    }\n  }\n  \n  finalResponse = finalResponse.replace('{{available_options}}', availableOptions);\n}\n\nreturn {\n  response: finalResponse,\n  state: newState,\n  remoteJid: $('Parse Webhook Data').item.json.remote_jid,\n  tenantId: $('Parse Webhook Data').item.json.tenant_id\n};"
      },
      "id": "5d70b14c-f539-43e7-8dd0-76a7a407ed11",
      "name": "Merge Template + Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        700
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "response",
              "name": "response",
              "type": "string",
              "value": "={{ $json.response_text }}"
            }
          ]
        },
        "options": {}
      },
      "id": "a881cc0d-1586-44cb-a42e-4d3d88bfb086",
      "name": "Use Template Directly",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3360,
        600
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "is-selection",
              "leftValue": "={{ $('Transition State').item.json.new_state }}",
              "rightValue": "awaiting_professional",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "8f433763-dfc7-4819-9e92-5343c5a5f13c",
      "name": "Service Selected?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1680,
        700
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  service_id AS id,\n  service_name AS name,\n  service_code,\n  service_category,\n  service_number\nFROM get_service_by_number(\n  '{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid,\n  {{ $('Parse Webhook Data').item.json.message_text }}::integer\n);",
        "options": {}
      },
      "id": "a18e9ba4-6bd6-4654-b4b3-24037ab6e5a9",
      "name": "Get Selected Service",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1920,
        700
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT update_conversation_state_data(\n  '{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid,\n  '{{ $('Parse Webhook Data').item.json.remote_jid }}',\n  '{{ $json.id }}'::uuid,\n  NULL,\n  NULL,\n  '{\"selected_service_name\": \"{{ $json.name }}\"}'\n);",
        "options": {}
      },
      "id": "54e53f0f-e23f-4fce-9cac-073f69d34867",
      "name": "Save Service Selection",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2160,
        700
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  p.professional_id AS id,\n  p.professional_name AS name,\n  p.specialty,\n  ROW_NUMBER() OVER (ORDER BY p.professional_name) AS number\nFROM professionals p\nJOIN professional_services ps ON ps.professional_id = p.professional_id\nWHERE ps.service_id = '{{ $('Get Selected Service').item.json.id }}'::uuid\n  AND p.is_active = true\n  AND ps.is_active = true;",
        "options": {}
      },
      "id": "14baf79b-14de-4dec-abb6-74dc57b808c5",
      "name": "Get Professionals for Service",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2400,
        700
      ],
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format professionals list\nconst professionals = $input.all();\nlet list = '';\n\nprofessionals.forEach((prof, index) => {\n  list += `${index + 1}Ô∏è‚É£ *${prof.json.name}*\\n   ${prof.json.specialty}\\n\\n`;\n});\n\nreturn {\n  professional_list: list,\n  professionals: professionals.map(p => p.json)\n};"
      },
      "id": "e031e6c1-09d1-4726-82ef-02b93f9b09b7",
      "name": "Format Professionals List",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// ===================================\n// SIMPLE MESSAGE FORMATTER\n// Replaces AI-based formatter\n// Cost: ~$0 (no AI call)\n// Latency: ~5ms vs ~800ms\n// ===================================\n\n// Try multiple sources in order of priority:\n// 1. formatted_text (from Use FAQ Answer node - may contain \\n literals)\n// 2. output (from Patient Assistant Agent - LangChain agent)\n// 3. answer (from Check FAQ Cache - raw database result)\n// 4. text (alternative agent output field)\n// 5. message_text (fallback)\nconst rawText = $json.formatted_text || $json.output || $json.answer || $json.text || $json.message_text || '';\n\n// Validate we have text to format\nif (!rawText || (typeof rawText === 'string' && rawText.trim() === '')) {\n  console.log('Format Message: No text found in:', Object.keys($json));\n  return {\n    ...$json,\n    formatted_text: 'Desculpe, ocorreu um erro. Por favor, tente novamente.'\n  };\n}\n\n// Convert to string if needed\nconst textToFormat = String(rawText);\n\n// Simple formatting rules for WhatsApp\n// IMPORTANT: Always process text to convert \\n literals to actual newlines\nlet formatted = textToFormat\n  // Replace literal \\\\n (escaped backslash + n) with actual newlines\n  // This handles strings coming from database or JSON that have \\n as literal characters\n  .replace(/\\\\n/g, '\\n')\n  // Also handle \\r\\n (Windows line breaks)\n  .replace(/\\\\r\\\\n/g, '\\n')\n  // Handle \\r (old Mac line breaks)\n  .replace(/\\\\r/g, '\\n')\n  // Convert markdown bold ** to WhatsApp bold *\n  .replace(/\\*\\*(.+?)\\*\\*/g, '*$1*')\n  // Remove markdown headers #\n  .replace(/^#{1,6}\\s+/gm, '')\n  // Convert markdown lists to WhatsApp bullets\n  .replace(/^[-*]\\s+/gm, '‚Ä¢ ')\n  // Clean up excessive newlines (3+ become 2)\n  .replace(/\\n{3,}/g, '\\n\\n')\n  // Trim whitespace\n  .trim();\n\n// Preserve all original fields and add formatted_text\nreturn {\n  ...$json,\n  formatted_text: formatted,\n  // Explicitly preserve essential fields for Update FAQ Cache (in case they were lost)\n  tenant_id: $json.tenant_id || $('Parse Webhook Data')?.first()?.json?.tenant_id,\n  message_text: $json.message_text || $json.message_text_normalized || $('Parse Webhook Data')?.first()?.json?.message_text || '',\n  intent: $json.intent || $json.intent_for_faq || $('Parse Webhook Data')?.first()?.json?.intent || ''\n};"
      },
      "id": "e2072431-e7d3-48c1-b926-2a24d9737ee7",
      "name": "Format Message (Code)",
      "type": "n8n-nodes-base.code",
      "position": [
        3600,
        400
      ],
      "typeVersion": 2,
      "notes": "‚ö° Formatador de mensagens sem IA (~5ms vs ~800ms)\n\n**Convers√µes**:\n- Markdown `**bold**` ‚Üí WhatsApp `*bold*`\n- Literal `\\n` ‚Üí Quebras de linha reais\n- Headers `#` ‚Üí Removidos\n- Listas markdown ‚Üí Bullets WhatsApp\n- Limpeza de espa√ßos excessivos\n\n**Performance**: ~5ms (vs ~800ms com IA)\n**Custo**: $0 (vs ~$0.001 por mensagem com IA)"
    },
    {
      "parameters": {
        "jsCode": "// Normalize message text from different input sources\n// Handles outputs from: Merge Template + Data, Use Template Directly, AI Agent\nconst rawText = $json.response || $json.response_text || $json.output || $json.text || $json.formatted_text || '';\n\n// Validate and convert to string\nlet messageText = '';\nif (rawText) {\n  if (typeof rawText === 'string') {\n    messageText = rawText.trim();\n  } else if (typeof rawText === 'object' && rawText !== null) {\n    // If it's an object, try to stringify it\n    messageText = JSON.stringify(rawText);\n  } else {\n    messageText = String(rawText);\n  }\n}\n\n// Ensure we always have a valid message\nif (!messageText || messageText === '') {\n  messageText = 'Desculpe, ocorreu um erro. Por favor, tente novamente.';\n}\n\n// Preserve all original fields and add normalized message_text\nreturn {\n  ...$json,\n  message_text: messageText\n};"
      },
      "id": "720edcec-71ad-4f07-ae31-95e4a256c52e",
      "name": "Normalize Message Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3840,
        400
      ]
    },
    {
      "parameters": {
        "resource": "messages-api",
        "instanceName": "={{ $('Parse Webhook Data').item.json.tenant_config.evolution_instance_name }}",
        "remoteJid": "={{ $('Parse Webhook Data').item.json.remote_jid }}",
        "messageText": "={{ $json.formatted_text }}",
        "options_message": {}
      },
      "id": "04264f61-3975-4dd8-b731-042667a71599",
      "name": "Send WhatsApp Response",
      "type": "n8n-nodes-evolution-api.evolutionApi",
      "position": [
        4080,
        300
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Update FAQ view count or insert new FAQ\n-- Get tenant_id from current node, fallback to Parse Webhook Data if needed\n-- This will fail gracefully if tenant_id is empty (workflow will continue)\nINSERT INTO tenant_faq (\n  tenant_id,\n  question_original,\n  question_normalized,\n  answer,\n  answer_type,\n  keywords,\n  intent,\n  view_count\n) VALUES (\n  '{{ $json.tenant_id || $('Parse Webhook Data').first()?.json?.tenant_id }}'::UUID,\n  '{{ ($json.message_text || $('Parse Webhook Data').first()?.json?.message_text || \"unknown\").replace(/'/g, \"''\") }}',\n  LOWER('{{ ($json.message_text || $('Parse Webhook Data').first()?.json?.message_text || \"unknown\").replace(/'/g, \"''\") }}'),\n  '{{ ($json.formatted_text || \"no answer\").replace(/'/g, \"''\") }}',\n  'text',\n  ARRAY['{{ ($json.intent || $('Parse Webhook Data').first()?.json?.intent || \"unknown\").replace(/'/g, \"''\") }}'],\n  '{{ ($json.intent || $('Parse Webhook Data').first()?.json?.intent || \"\").replace(/'/g, \"''\") }}',\n  1\n)\nON CONFLICT (tenant_id, question_normalized)\nDO UPDATE SET\n  view_count = tenant_faq.view_count + 1,\n  last_used_at = NOW(),\n  answer = EXCLUDED.answer,\n  intent = EXCLUDED.intent;",
        "options": {}
      },
      "id": "a23dbfbe-e992-4aba-897b-669da69f4087",
      "name": "Update FAQ Cache",
      "type": "n8n-nodes-base.postgres",
      "position": [
        4080,
        500
      ],
      "typeVersion": 2.4,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üíæ Aprende com intera√ß√µes para melhorar o FAQ\n\n**Funcionalidade**:\n- Insere nova FAQ se n√£o existir\n- Atualiza `view_count` se j√° existir\n- Atualiza `last_used_at` para ordena√ß√£o\n- Normaliza pergunta para busca futura\n\n**Efeito**: Sistema melhora automaticamente com o tempo"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT gsbn.*, '{{ $json.tenant_id }}'::UUID AS tenant_id FROM get_service_by_number('{{ $json.tenant_id }}'::UUID, {{ $json.service_number }}::INTEGER) gsbn;",
        "options": {}
      },
      "id": "50be97ae-e438-41fe-8f0a-04ef6b306455",
      "name": "Get Service by Number (AI Path)",
      "type": "n8n-nodes-base.postgres",
      "position": [
        3120,
        300
      ],
      "typeVersion": 2.4,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "üîç Get service details by catalog number (no AI)"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "FVyU7WmQX73SHQcs",
          "mode": "id",
          "cachedResultName": "Find Professionals Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id || $('Merge FAQ Result').first()?.json?.tenant_id }}",
            "service_name": "={{ $json.service_name }}"
          }
        },
        "options": {}
      },
      "id": "879861b1-4278-4c53-a8cf-0b4b13575637",
      "name": "Find Professionals (Direct)",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        3360,
        300
      ],
      "typeVersion": 1.2,
      "notes": "üîç Find professionals for selected service (no AI)"
    },
    {
      "parameters": {
        "jsCode": "// Process professionals and prepare for calendar check\n// CRITICAL: Restore context lost by Postgres nodes (they strip input data)\nconst ctx = $('Merge FAQ Result').first()?.json || {};\nconst serviceData = $('Get Service by Number').first()?.json || {};\nconst professionalsData = $json || {};\n\n// Context fields needed downstream (Format Message, Send WhatsApp, Update FAQ)\nconst context = {\n  tenant_id: serviceData.tenant_id || ctx.tenant_id,\n  remote_jid: ctx.remote_jid,\n  push_name: ctx.push_name,\n  tenant_config: ctx.tenant_config,\n  message_text: ctx.message_text,\n  intent: ctx.intent,\n  services_catalog: ctx.services_catalog\n};\n\n// Get professionals array\nconst professionals = professionalsData.professionals || [];\n\nif (professionals.length === 0) {\n  return {\n    ...context,\n    ...serviceData,\n    formatted_text: 'Desculpe, n√£o encontrei profissionais dispon√≠veis para este servi√ßo no momento.'\n  };\n}\n\n// If single professional, prepare for direct calendar check\nif (professionals.length === 1) {\n  const prof = professionals[0];\n  const service = prof.services?.[0] || {};\n  return {\n    ...context,\n    ...serviceData,\n    professional: prof,\n    professional_id: prof.professional_id,\n    professional_name: prof.professional_name,\n    google_calendar_id: prof.google_calendar_id,\n    duration_minutes: service.duration_minutes || 30,\n    price_display: service.price_display || 'R$ 0,00',\n    single_professional: true,\n    calendar_check_needed: true\n  };\n}\n\n// Multiple professionals - expand each into a separate item\nconst expandedItems = professionals.map((prof) => {\n  const service = prof.services?.[0] || {};\n  return {\n    ...context,\n    ...serviceData,\n    professional: prof,\n    professional_id: prof.professional_id,\n    professional_name: prof.professional_name,\n    google_calendar_id: prof.google_calendar_id,\n    duration_minutes: service.duration_minutes || 30,\n    price_display: service.price_display || 'R$ 0,00',\n    single_professional: false,\n    calendar_check_needed: true,\n    multiple_professionals: true,\n    total_professionals: professionals.length\n  };\n});\n\nreturn expandedItems;"
      },
      "id": "279c2fbe-5e0c-4d56-b40d-88bc32a898c4",
      "name": "Process Professionals",
      "type": "n8n-nodes-base.code",
      "position": [
        3600,
        300
      ],
      "typeVersion": 2,
      "notes": "‚öôÔ∏è Process professionals list (no AI)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.single_professional }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "50fd0ad3-5b27-4497-9f7f-35da2081638d",
      "name": "Single Professional?",
      "type": "n8n-nodes-base.if",
      "position": [
        3840,
        300
      ],
      "typeVersion": 2,
      "notes": "üîÄ Check if single professional (direct calendar) or multiple (user choice)"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "iaQfqBe29sPuLxLS",
          "mode": "id",
          "cachedResultName": "Google Calendar Availability Tool"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.tenant_id || $('Merge FAQ Result').first()?.json?.tenant_id }}",
            "calendar_id": "={{ $json.google_calendar_id }}",
            "start_time": "={{ new Date().toISOString() }}",
            "end_time": "={{ new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() }}",
            "duration_minutes": "={{ $json.duration_minutes || 30 }}"
          }
        },
        "options": {}
      },
      "id": "8b9fc45c-f862-4d23-8473-6f6aacef33e6",
      "name": "Check Calendar (Direct)",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [
        4080,
        200
      ],
      "typeVersion": 1.2,
      "notes": "üìÖ Check calendar availability (no AI)"
    },
    {
      "parameters": {
        "jsCode": "// Format calendar availability slots for presentation\n// Check if we have multiple items (multiple professionals)\nconst allItems = $input.all();\nconst isMultiple = allItems.length > 1;\n\n// Get service data\nconst service = $('Get Service by Number').first()?.json || {};\n\nif (isMultiple) {\n  // Multiple professionals - collect all results and format together\n  const professionalResults = allItems.map((item, index) => {\n    const calendarData = item.json || {};\n    const slots = calendarData.available_slots || [];\n    const professional = item.json.professional || item.json.professional_name ? { professional_name: item.json.professional_name } : {};\n    \n    // Show 5 slots per professional\n    const slotsToShow = slots.slice(0, 5);\n    \n    if (slotsToShow.length === 0) {\n      return `\\n*${professional.professional_name || 'Profissional ' + (index + 1)}:*\\nSem hor√°rios dispon√≠veis nos pr√≥ximos 7 dias.`;\n    }\n    \n    const slotsFormatted = slotsToShow.map((slot, idx) => {\n      return `  ${idx + 1}. ${slot.date_formatted} √†s ${slot.start_formatted}`;\n    }).join('\\n');\n    \n    return `\\n*${professional.professional_name || 'Profissional ' + (index + 1)}:*\\n${slotsFormatted}`;\n  }).join('\\n\\n');\n  \n  return {\n    ...allItems[0].json,\n    ...service,\n    formatted_text: `üìÖ *Hor√°rios dispon√≠veis para ${service.service_name || 'este servi√ßo'}:*\\n${professionalResults}\\n\\n*Qual profissional e hor√°rio voc√™ prefere? (Responda com o n√∫mero do profissional e do hor√°rio)*`,\n    multiple_professionals: true\n  };\n} else {\n  // Single professional - format as before (10 slots)\n  const calendarData = $json || {};\n  const slots = calendarData.available_slots || [];\n  const professional = $('Process Professionals').first()?.json?.professional || {};\n  \n  if (slots.length === 0) {\n    return {\n      ...$json,\n      formatted_text: `Desculpe, n√£o encontrei hor√°rios dispon√≠veis para *${service.service_name || 'este servi√ßo'}* com ${professional.professional_name || 'o profissional'} nos pr√≥ximos 7 dias.\\n\\nPor favor, tente novamente mais tarde ou entre em contato conosco.`\n    };\n  }\n  \n  // Show 10 slots for single professional\n  const slotsToShow = slots.slice(0, 10);\n  const slotsListFormatted = slotsToShow.map((slot, idx) => {\n    return `${idx + 1}. ${slot.date_formatted} √†s ${slot.start_formatted} (dura√ß√£o: ${slot.duration_minutes}min)`;\n  }).join('\\n');\n  \n  return {\n    ...$json,\n    ...professional,\n    ...service,\n    formatted_text: `üìÖ *Hor√°rios dispon√≠veis para ${service.service_name || 'este servi√ßo'} com ${professional.professional_name || 'o profissional'}:*\\n\\n${slotsListFormatted}\\n\\n*Qual hor√°rio voc√™ prefere? (Responda com o n√∫mero)*`,\n    available_slots: slots,\n    slots_count: slots.length\n  };\n}"
      },
      "id": "353d14f6-0d24-4a7f-aadf-db61f8f71379",
      "name": "Format Calendar Slots",
      "type": "n8n-nodes-base.code",
      "position": [
        4320,
        200
      ],
      "typeVersion": 2,
      "notes": "üìù Format calendar slots for presentation (no AI)"
    },
    {
      "parameters": {
        "content": "## üìã 01 - WhatsApp Main Handler (Merged)\n\n**Version**: 5.0 ‚Äî State Machine + 3-Layer Defense\n\n### Architecture\n- **Backbone**: DB-driven conversation state machine (12 states)\n- **AI Defense**: FAQ Cache ‚Üí Template ‚Üí AI Agent (3-layer)\n- **Media**: Audio transcription + Image OCR (gated by feature flags)\n- **Multi-tenant**: All queries scoped by tenant_id\n\n### Flow\n1. Webhook ‚Üí Tenant Config Loader (sub-workflow)\n2. Parse ‚Üí Message Type Switch\n3. State Machine: get/create state ‚Üí transition\n4. If requires_ai ‚Üí 3-layer defense (FAQ ‚Üí Template ‚Üí AI)\n5. If !requires_ai ‚Üí DB template response with dynamic data\n6. Format ‚Üí Normalize ‚Üí Send WhatsApp\n\n### Credential Placeholders\n- `{{POSTGRES_CREDENTIAL_ID}}`\n- `{{OPENROUTER_CREDENTIAL_ID}}`\n- `{{EVOLUTION_CREDENTIAL_ID}}`",
        "height": 500,
        "width": 450,
        "color": 5
      },
      "id": "26e7b11c-4d5b-4570-a955-1b9da8f13ac4",
      "name": "Sticky Note - Documentation",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -400,
        100
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT * FROM enqueue_message(\n  '{{ $json.tenant_id }}'::uuid,\n  '{{ $json.remote_jid }}',\n  '{{ $json.message_id }}',\n  '{}'::jsonb\n);",
        "options": {}
      },
      "id": "enqueue-message",
      "name": "Enqueue Message",
      "type": "n8n-nodes-base.postgres",
      "position": [560, 150],
      "typeVersion": 2.5,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "Deduplication: inserts message into queue with UNIQUE constraint on (tenant_id, message_id). Returns status 'queued' or 'duplicate'."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "is-duplicate",
              "leftValue": "={{ $json.status }}",
              "rightValue": "duplicate",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "is-duplicate",
      "name": "Is Duplicate?",
      "type": "n8n-nodes-base.if",
      "position": [700, 150],
      "typeVersion": 2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT acquire_conversation_lock(\n  '{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid,\n  '{{ $('Parse Webhook Data').item.json.remote_jid }}'\n) AS lock_acquired;",
        "options": {}
      },
      "id": "acquire-lock",
      "name": "Acquire Lock",
      "type": "n8n-nodes-base.postgres",
      "position": [580, 400],
      "typeVersion": 2.5,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "Conversation lock: prevents concurrent processing of messages from same phone number. Lock expires after 5 minutes."
    },
    {
      "parameters": {
        "jsCode": "// Restore context from Parse Webhook Data after dedup/lock Postgres nodes\n// Postgres nodes replace $json with query results, so we need to recover\nreturn $('Parse Webhook Data').first().json;"
      },
      "id": "restore-context",
      "name": "Restore Context",
      "type": "n8n-nodes-base.code",
      "position": [660, 400],
      "typeVersion": 2,
      "notes": "Restores all parsed webhook data lost during dedup/lock Postgres queries."
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT release_conversation_lock(\n  '{{ $('Parse Webhook Data').item.json.tenant_id }}'::uuid,\n  '{{ $('Parse Webhook Data').item.json.remote_jid }}'\n);",
        "options": {}
      },
      "id": "release-lock",
      "name": "Release Lock",
      "type": "n8n-nodes-base.postgres",
      "position": [4300, 350],
      "typeVersion": 2.5,
      "credentials": {
        "postgres": {
          "id": "{{POSTGRES_CREDENTIAL_ID}}",
          "name": "Postgres account"
        }
      },
      "notes": "Releases conversation lock after message processing completes."
    }
  ],
  "pinData": {},
  "connections": {
    "WhatsApp Webhook": {
      "main": [
        [
          {
            "node": "Load Tenant Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Tenant Config": {
      "main": [
        [
          {
            "node": "Parse Webhook Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Webhook Data": {
      "main": [
        [
          {
            "node": "Enqueue Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enqueue Message": {
      "main": [
        [
          {
            "node": "Is Duplicate?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Duplicate?": {
      "main": [
        [],
        [
          {
            "node": "Acquire Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Acquire Lock": {
      "main": [
        [
          {
            "node": "Restore Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Context": {
      "main": [
        [
          {
            "node": "Message Type Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message Type Switch": {
      "main": [
        [
          {
            "node": "Get Conversation State",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Image Feature",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Audio Feature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Audio Feature": {
      "main": [
        [
          {
            "node": "Process Audio",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Audio Not Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Audio": {
      "main": [
        [
          {
            "node": "Get Conversation State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audio Not Available": {
      "main": [
        [
          {
            "node": "Get Conversation State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Image Feature": {
      "main": [
        [
          {
            "node": "Process Image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Image Not Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image": {
      "main": [
        [
          {
            "node": "Get Conversation State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Image Not Available": {
      "main": [
        [
          {
            "node": "Get Conversation State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Conversation State": {
      "main": [
        [
          {
            "node": "Transition State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transition State": {
      "main": [
        [
          {
            "node": "Requires AI?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Service Selected?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Requires AI?": {
      "main": [
        [
          {
            "node": "Intent Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Template Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intent Classifier": {
      "main": [
        [
          {
            "node": "Check FAQ Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check FAQ Cache": {
      "main": [
        [
          {
            "node": "Merge FAQ Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge FAQ Result": {
      "main": [
        [
          {
            "node": "Needs AI?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs AI?": {
      "main": [
        [
          {
            "node": "Build Prompt with Catalog",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No-AI Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt with Catalog": {
      "main": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Patient Assistant Agent": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No-AI Router": {
      "main": [
        [
          {
            "node": "Get Service by Number (AI Path)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Resolve Template",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Use FAQ Answer",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt with Catalog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Template": {
      "main": [
        [
          {
            "node": "Use Template Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Template Answer": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use FAQ Answer": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Service by Number (AI Path)": {
      "main": [
        [
          {
            "node": "Find Professionals (Direct)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Professionals (Direct)": {
      "main": [
        [
          {
            "node": "Process Professionals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Professionals": {
      "main": [
        [
          {
            "node": "Single Professional?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Single Professional?": {
      "main": [
        [
          {
            "node": "Check Calendar (Direct)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Calendar (Direct)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Calendar (Direct)": {
      "main": [
        [
          {
            "node": "Format Calendar Slots",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Calendar Slots": {
      "main": [
        [
          {
            "node": "Format Message (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Template Response": {
      "main": [
        [
          {
            "node": "Needs Available Options?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Available Options?": {
      "main": [
        [
          {
            "node": "Get Available Options",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Dynamic Data?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Available Options": {
      "main": [
        [
          {
            "node": "Needs Dynamic Data?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Dynamic Data?": {
      "main": [
        [
          {
            "node": "Get Services List",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Use Template Directly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Services List": {
      "main": [
        [
          {
            "node": "Merge Template + Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Service Selected?": {
      "main": [
        [
          {
            "node": "Get Selected Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Selected Service": {
      "main": [
        [
          {
            "node": "Save Service Selection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Service Selection": {
      "main": [
        [
          {
            "node": "Get Professionals for Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Professionals for Service": {
      "main": [
        [
          {
            "node": "Format Professionals List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Professionals List": {
      "main": [
        [
          {
            "node": "Merge Template + Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Template + Data": {
      "main": [
        [
          {
            "node": "Normalize Message Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Template Directly": {
      "main": [
        [
          {
            "node": "Normalize Message Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Message (Code)": {
      "main": [
        [
          {
            "node": "Normalize Message Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Message Text": {
      "main": [
        [
          {
            "node": "Send WhatsApp Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update FAQ Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Find Professionals Tool": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "List Calendar Events": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Check Calendar Availability": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Create Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Human Escalation Tool": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Delete Calendar Event": {
      "ai_tool": [
        [
          {
            "node": "Patient Assistant Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp Response": {
      "main": [
        [
          {
            "node": "Release Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "errorWorkflow": "{{ERROR_HANDLER_WORKFLOW_ID}}"
  },
  "versionId": "6935e188-c3bf-4f9d-adeb-b43ee694433c",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bc055219b8ddb8cb6a3ed41fcda359f13436b13a927934d06acc0a1be80d63bb"
  },
  "id": "merged-whatsapp-main",
  "tags": [
    {
      "name": "production",
      "id": "d0526270-ed6f-4e10-9115-1b6c8cc1e792"
    },
    {
      "name": "main",
      "id": "fd6a307f-f713-4cea-bace-04ea91ce53c5"
    },
    {
      "name": "multi-tenant",
      "id": "77ea71e5-cf3a-476e-bc62-6029eef68291"
    },
    {
      "name": "state-machine",
      "id": "b74a7fab-622e-4f08-8ead-79942af1d149"
    },
    {
      "name": "optimized",
      "id": "16de3590-d304-4c96-9c77-8bee6456671b"
    }
  ]
}