{
  "name": "Google Calendar Availability Tool",
  "nodes": [
    {
      "parameters": {},
      "id": "workflow-trigger",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [240, 300],
      "typeVersion": 1
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "calendar_id",
              "name": "calendar_id",
              "type": "string",
              "value": "={{ $json.calendar_id || $json.google_calendar_id }}"
            },
            {
              "id": "start_time",
              "name": "start_time",
              "type": "string",
              "value": "={{ $json.start_time || $json.timeMin }}"
            },
            {
              "id": "end_time",
              "name": "end_time",
              "type": "string",
              "value": "={{ $json.end_time || $json.timeMax }}"
            },
            {
              "id": "duration_minutes",
              "name": "duration_minutes",
              "type": "number",
              "value": "={{ $json.duration_minutes || 30 }}"
            }
          ]
        }
      },
      "id": "extract-params",
      "name": "Extract Parameters",
      "type": "n8n-nodes-base.set",
      "position": [460, 300],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": "={{ $json.calendar_id }}",
        "returnAll": true,
        "options": {
          "timeMin": "={{ $json.start_time }}",
          "timeMax": "={{ $json.end_time }}"
        }
      },
      "id": "check-availability",
      "name": "Check Availability",
      "type": "n8n-nodes-base.googleCalendar",
      "position": [680, 300],
      "typeVersion": 1,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "{{GOOGLE_CALENDAR_CREDENTIAL_ID}}",
          "name": "Google Calendar OAuth2"
        }
      },
      "notes": "üìÖ Consulta eventos para determinar disponibilidade (usa Get Many em vez de freebusy)"
    },
    {
      "parameters": {
        "jsCode": "// Process events list and return available slots\n// Considera dura√ß√£o do procedimento e retorna apenas as 10 op√ß√µes mais pr√≥ximas\n// Converte eventos em per√≠odos ocupados (busy periods)\nconst allEvents = $input.all();\nconst calendarId = $('Extract Parameters').item.json.calendar_id;\n\n// Parse start and end times\nconst startTime = new Date($('Extract Parameters').item.json.start_time);\nconst endTime = new Date($('Extract Parameters').item.json.end_time);\n\n// Get duration from parameters (default 30 minutes if not provided)\nconst durationMinutes = parseInt($('Extract Parameters').item.json.duration_minutes) || 30;\n\n// Convert events to busy periods format\nconst busyPeriods = allEvents.map(event => ({\n  start: event.json.start?.dateTime || event.json.start?.date || null,\n  end: event.json.end?.dateTime || event.json.end?.date || null\n})).filter(period => period.start && period.end);\n\n// Generate available slots based on procedure duration\nconst slotDuration = durationMinutes * 60 * 1000; // Convert to milliseconds\nconst availableSlots = [];\nlet currentTime = new Date(startTime);\n\n// Define working hours (06:00 to 20:00 by default)\nconst workStart = new Date(currentTime);\nworkStart.setHours(6, 0, 0, 0);\nconst workEnd = new Date(currentTime);\nworkEnd.setHours(20, 0, 0, 0);\n\n// Start from work start or requested start time, whichever is later\nif (currentTime < workStart) {\n  currentTime = new Date(workStart);\n}\n\n// Generate slots checking availability and working hours\nwhile (currentTime < endTime && availableSlots.length < 10) {\n  const slotEnd = new Date(currentTime.getTime() + slotDuration);\n  \n  // Check if slot is within working hours\n  const slotStartHour = currentTime.getHours();\n  const slotEndHour = slotEnd.getHours();\n  \n  if (slotStartHour >= 6 && slotEndHour <= 20 && slotEnd <= endTime) {\n    // Check if this slot overlaps with any busy period\n    const isBusy = busyPeriods.some(busy => {\n      const busyStart = new Date(busy.start);\n      const busyEnd = new Date(busy.end);\n      return (currentTime < busyEnd && slotEnd > busyStart);\n    });\n    \n    if (!isBusy) {\n      // Format date for display\n      const dateStr = currentTime.toLocaleDateString('pt-BR', { \n        weekday: 'long', \n        day: '2-digit', \n        month: 'long',\n        year: 'numeric'\n      });\n      \n      availableSlots.push({\n        start: currentTime.toISOString(),\n        end: slotEnd.toISOString(),\n        start_formatted: currentTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),\n        end_formatted: slotEnd.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),\n        date_formatted: dateStr.charAt(0).toUpperCase() + dateStr.slice(1),\n        duration_minutes: durationMinutes\n      });\n    }\n  }\n  \n  // Move to next slot (increment by 15 minutes for better granularity)\n  currentTime = new Date(currentTime.getTime() + (15 * 60 * 1000));\n  \n  // If we've passed work end for today, move to next day at work start\n  if (currentTime.getHours() >= 20) {\n    currentTime.setDate(currentTime.getDate() + 1);\n    currentTime.setHours(6, 0, 0, 0);\n  }\n}\n\n// Sort by start time (should already be sorted, but ensure it)\navailableSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n// Limit to 10 most upcoming slots\nconst topSlots = availableSlots.slice(0, 10);\n\nreturn {\n  calendar_id: calendarId,\n  start_time: startTime.toISOString(),\n  end_time: endTime.toISOString(),\n  duration_minutes: durationMinutes,\n  available_slots: topSlots,\n  available_count: topSlots.length,\n  total_slots_found: availableSlots.length,\n  busy_periods: busyPeriods.length,\n  message: topSlots.length > 0 \n    ? `Encontrei ${topSlots.length} hor√°rio${topSlots.length > 1 ? 's' : ''} dispon√≠vel${topSlots.length > 1 ? 'eis' : ''} para procedimento de ${durationMinutes} minutos.`\n    : `N√£o encontrei hor√°rios dispon√≠veis para procedimento de ${durationMinutes} minutos no per√≠odo consultado.`\n};"
      },
      "id": "process-availability",
      "name": "Process Availability",
      "type": "n8n-nodes-base.code",
      "position": [900, 300],
      "typeVersion": 2
    }
  ],
  "pinData": {},
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Extract Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Parameters": {
      "main": [
        [
          {
            "node": "Check Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Availability": {
      "main": [
        [
          {
            "node": "Process Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "google-calendar-availability-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "clinic-multiagent-system"
  },
  "tags": [
    {
      "name": "tool",
      "id": "1"
    },
    {
      "name": "calendar",
      "id": "4"
    },
    {
      "name": "google-api",
      "id": "6"
    }
  ]
}
